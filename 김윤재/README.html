<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>*알고리즘 트레이닝* 의 정리</title>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        
    </head>
    <body class="vscode-light">
        <h1 id="%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%ed%8a%b8%eb%a0%88%ec%9d%b4%eb%8b%9d-%ec%9d%98-%ec%a0%95%eb%a6%ac"><em>알고리즘 트레이닝</em> 의 정리</h1>
<h3 id="guide-to-competitive-programming-learning-and-improving-algorithms-through-contests-by-antti-laaksonen">( <em>Guide to Competitive Programming: Learning and Improving Algorithms Through Contests</em> by Antti Laaksonen )</h3>
<h2 id="1%ec%9e%a5-%ec%83%9d%eb%9e%b5">1장 생략</h2>
<h2 id="2%ec%9e%a5--%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%b0%8d-%ea%b8%b0%eb%b2%95-programming-techniques">2장 : 프로그래밍 기법 <em>Programming Techniques</em></h2>
<p>이 장은 C++ 프로그래밍의 특징, 재귀, 비트연산을 다룬다.</p>
<h3 id="21-%ec%96%b8%ec%96%b4%ec%a0%81-%ed%8a%b9%ec%84%b1-language-features">2.1 언어적 특성 <em>Language Features</em></h3>
<p>표쥰적 경진 프로그래밍 코드 형태 :</p>
<pre><code class="language-cpp"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">//code</span>
}
</div></code></pre>
<p>&lt;bits.stdc++&gt; 은 표준 라이브러리 전체를 포함한다. (iostream, vector, algrotihm 등 포함)</p>
<h4 id="211-%ec%9e%85%eb%a0%a5%ea%b3%bc-%ec%b6%9c%eb%a0%a5">2.1.1 입력과 출력</h4>
<ul>
<li>표준 stream 으로 입출력 처리한다.</li>
</ul>
<pre><code class="language-cpp"><div><span class="hljs-keyword">int</span> a,b;
<span class="hljs-built_in">string</span> str;
<span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;str;
</div></code></pre>
<p>개행이나 공백으로 입력 분리된다.</p>
<ul>
<li>간혹 입출력이 프로그램의 병목이 될 때가 있으면 아래와 같이 처리한다.</li>
</ul>
<pre><code class="language-cpp"><div>ios::sync_with_stdio(<span class="hljs-number">0</span>); <span class="hljs-comment">//standard stream synch -&gt; false</span>
<span class="hljs-built_in">cin</span>.tie(<span class="hljs-number">0</span>); <span class="hljs-comment">//unties cin from cout</span>
</div></code></pre>
<ul>
<li>
<p>endl 보다 &quot;\n&quot; 이 더 빠르다.</p>
</li>
<li>
<p>데이터 양을 모를때 반복문으로 처리한다. 하나씩 읽어 들이다 데이터가 없을 때 멈춘다.</p>
</li>
</ul>
<pre><code class="language-cpp"><div><span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;x){
<span class="hljs-comment">//code</span>
}
</div></code></pre>
<ul>
<li>데이터가 파일로 주어지면 평소처럼 표준 스트림을 이용하는 방법은 입력이 input.txt, 출력을 output.txt로 할때 다음과 같다.</li>
</ul>
<pre><code class="language-cpp"><div>freopen(<span class="hljs-string">"input.txt"</span>,<span class="hljs-string">"r"</span>,<span class="hljs-built_in">stdin</span>);
freopen(<span class="hljs-string">"output.txt"</span>,<span class="hljs-string">"w"</span>,<span class="hljs-built_in">stdout</span>);
</div></code></pre>
<h4 id="212-%ec%88%98%ec%9d%98-%ec%b2%98%eb%a6%ac">2.1.2 수의 처리</h4>
<ul>
<li>정수의 처리
알고리즘 경진에서 int의 범위(최대 2^31-1)를 벗어나게 되는 큰 수는 보통 long long으로 처리하게 된다. 이때 조심해야 할 버그가 있다.</li>
</ul>
<pre><code class="language-cpp"><div><span class="hljs-keyword">int</span> x = <span class="hljs-number">6666666666</span>;
<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> y = x*x;
<span class="hljs-built_in">cout</span>&lt;&lt;y&lt;&lt;<span class="hljs-string">"\n"</span>; <span class="hljs-comment">//Overflows.</span>
</div></code></pre>
<p>이는 y의 자료형이 long long이지만 x*x에 포함된 수의 자료형이 int로 결과도 int로 처리되기 때문이다.</p>
<pre><code class="language-cpp"><div><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> y = (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)x*x;
</div></code></pre>
<p>로 바꾸어주면 된다.</p>
<ul>
<li>나머지 연산
나머지 (Modulo) 연산은 (a+b) mod m = ( (a mod m) + (b mod m) ) mod m 을 만족한다. 이를 이용하여 값을 작게 유지하기 위해 연산을 수행할 때마다 mod를 취해 주면 된다.
예를 들어 n!을 m으로 나눈 나머지를 구하는 코드가 있다.</li>
</ul>
<pre><code class="language-cpp"><div><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x=<span class="hljs-number">1</span>;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) x=(x*i)%m;
<span class="hljs-built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="hljs-string">"\n"</span>&gt;&gt;;
</div></code></pre>
<p>C++ 언어가 음수의 나머지를 음수로 취급함에 따라 음수면 m을 더해주면 된다.</p>
<pre><code class="language-cpp"><div><span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) x += m;
</div></code></pre>
<ul>
<li>부동 소수점 실수 (float, double)
long double이 정밀도가 높아 사용하기 좋다. 부동 소수점 오차는 == 연산자를 사용하지 않고 두 수의 차이가 ε 이하로 처리하여 사용할 수 있다. 출력도 다음과 같이 할 수 있다.\</li>
</ul>
<pre><code class="language-cpp"><div><span class="hljs-keyword">double</span> b=<span class="hljs-number">0.7</span>*<span class="hljs-number">3</span><span class="hljs-number">-1.1</span>;
<span class="hljs-keyword">double</span> a=<span class="hljs-number">0.3</span>*<span class="hljs-number">3</span>+<span class="hljs-number">0.1</span>;
<span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(a-b)&lt;<span class="hljs-number">1e-9</span>){ <span class="hljs-comment">// ε = 10^-9</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.20f\n"</span>,a);  
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.20f\n"</span>,b); 
<span class="hljs-comment">// a,b 값은 오차로 미묘하게 다르다.</span>
}
</div></code></pre>
<h3 id="213-%ec%a7%a7%ec%9d%80-%ec%bd%94%eb%93%9c">2.1.3 짧은 코드</h3>
<ul>
<li>자료형
typedef 로 자료형을 짧게 줄일 수 있다.</li>
</ul>
<pre><code class="language-cpp"><div><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;
</div></code></pre>
<ul>
<li>매크로
선처리 #define 으로 매크로를 정의할 수 있다.</li>
</ul>
<pre><code class="language-cpp"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> F first</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SWAP(x, y, T) do { T SWAP = x; x = y; y = SWAP; } while (0)</span>
</div></code></pre>
<p>SWAP 매크로는 타입을 사용해서</p>
<pre><code class="language-cpp"><div>SWAP(a, b, <span class="hljs-keyword">int</span>);
</div></code></pre>
<h3 id="22-%ec%9e%ac%ea%b7%80%ec%a0%81-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98">2.2 재귀적 알고리즘</h3>
<h3 id="221-%eb%b6%80%eb%b6%84%ec%a7%91%ed%95%a9-%ec%83%9d%ec%84%b1%ed%95%98%ea%b8%b0">2.2.1 부분집합 생성하기</h3>
<p>원소가 n개인 집합의 부분집합을 모두 생산하는 알고리즘을 재귀로 구현한다.
하나의 원소씩 포함하거나 제외하는 2^n 번의 과정을 재귀로 구현하기 좋다.</p>
<pre><code class="language-cpp"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">subsets</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; A, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; save, 
                 <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; currentSet, <span class="hljs-keyword">int</span> k)</span> 
</span>{ 
    save.push_back(currentSet); 
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k; i &lt; A.size(); i++) { 
        currentSet.push_back(A[i]); <span class="hljs-comment">// 원소 포함 </span>
        subsets(A, save, currentSet, i+<span class="hljs-number">1</span>); 
        currentSet.pop_back(); <span class="hljs-comment">// 원소 제외</span>
    } 
  
    <span class="hljs-keyword">return</span>; 
} 

</div></code></pre>
<h4 id="222-%ec%88%9c%ec%97%b4--permutations">2.2.2 순열 ( Permutations )</h4>
<p>부분집합과 유사한 방법으로 각 원소를 이번 순열에 포함 시켰는지 포함하지 않았는지를 결정하는 배열을 두고 재귀한다.</p>
<pre><code class="language-cpp"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">permutations</span><span class="hljs-params">(<span class="hljs-keyword">int</span> input, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; save)</span> 
</span>{
    <span class="hljs-keyword">if</span> (permutationSet.size()==input){
        save.push_back(permutationSet);
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= input; i++) {
        <span class="hljs-keyword">if</span>(chosen[i])<span class="hljs-keyword">continue</span>;
        chosen[i]=<span class="hljs-literal">true</span>;
        permutationSet.push_back(i);
        permutations(input,save);
        chosen[i]=<span class="hljs-literal">false</span>;
        permutationSet.pop_back();
    }    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; 
}

</div></code></pre>
<h4 id="223-%ed%87%b4%ea%b0%81-%ea%b2%80%ec%83%89--backtracking">2.2.3 퇴각 검색 ( Backtracking )</h4>
<h2 id="3%ec%9e%a5--%ed%9a%a8%ec%9c%a8%ec%84%b1">3장 : 효율성</h2>
<p>이 장은 알고리즘의 시간 복잡도를 다루어 알고리즘의 효율성을 다룬다.
빅오 표기법 (Big-O Notation) 과 앞서 소개된 문제의 시간 복잡도를 설명한다.</p>
<h2 id="4%ec%9e%a5--%ec%a0%95%eb%a0%ac%ea%b3%bc-%ed%83%90%ec%83%89">4장 : 정렬과 탐색</h2>
<p>4장에서는 입력된 데이터를 정렬하고 탐색하는 알고리즘을 다룬다.</p>
<h3 id="41-%ec%a0%95%eb%a0%ac-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98">4.1 정렬 알고리즘</h3>
<p>기본적인 정렬 문제는 원소가 n개 주어질 때 원소들을 크기가 증가하거나 감소하는 순서로 정렬하는 문제이다.</p>
<h4 id="411-bubble-sort">4.1.1 Bubble Sort</h4>
<p>버블 정렬(Bubble Sort)는 가장 직관적 정렬 알고리즘으로 <em>O(n^2)</em> 시간 동안 동작하며 간단한 2중 for 문으로 구현된다.</p>
<pre><code class="language-cpp"><div><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++){
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n<span class="hljs-number">-1</span>;j++){
        <span class="hljs-keyword">if</span>(arr[j]&gt;arr[j+<span class="hljs-number">1</span>])
        swap(arr[j],arr[j+<span class="hljs-number">1</span>]);
    }
}
</div></code></pre>
<p>가장 큰 원소부터 올바른 위치에 놓이게 되는 원리로 한 페어씩 비교되어 정렬된다.</p>
<h5 id="%ec%97%ad%ec%9c%84"><em>역위</em></h5>
<p><em>역위 (inversion)</em> 는 정렬 알고리즘을 분석할 때 유용한 개념이다.
배열의 index 는 a&lt;b 이지만 값 array[a]&gt;array[b] 일때 이를 역위라 한다.
역위의 개수가 배열을 정렬하는데 필요한 작업량을 결정한다.
정렬 알고리즘이 연달아 있는 원소만 바꾼다면 역위의 개수대로 연산을 해야해서
1+2+ ... (n-1) = n(n-1)/2 = <em>O(n^2)</em> 이 될 수 밖에 없다.</p>
<h4 id="412-merge-sort">4.1.2 Merge Sort</h4>
<p>정렬 알고리즘의 효율을 높이기 위해서는 배열의 바로 옆이 아닌 다른 위치에 있는 원소들의 순서를 바로 잡아야 한다.
그러한 방식을 이용하는 병합 정렬 (Merge Sort) 은 <em>O(n log n)</em> 시간 복잡도를 가진다.</p>
<p>병합 정렬은 부분 배열 arr[a,...,b]에 대해 다음과 같은 절차를 따라 재귀적으로 실행된다.</p>
<ol>
<li>원소가 하나 (a==b) 라면 아무것도 하지 않는다.</li>
<li>가운데 원소의 위치를 k = (a+b)/2 로 계산한다.</li>
<li>재귀적으로 arr[a,...,k]를 정렬한다.</li>
<li>재귀적으로 arr[k,...,b]를 정렬한다.</li>
<li>3번의 부분배열과 4번의 부분배열을 병합하여 정렬된 배열 arr[a,...,b]를 만든다.</li>
</ol>
<p>단계마다 부분배열의 크기를 절반으로 줄여 재귀 호출은 log2(n)으로 O(log n) 이 되고 각 단계의 처리가 *O(n)*이 되어 <em>O(n log n)</em> 복잡도가 된다.</p>
<pre><code class="language-cpp"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span>
</span>{
    <span class="hljs-keyword">int</span> mid;
    <span class="hljs-keyword">if</span> (low &lt; high){
       
        mid=(low+high)/<span class="hljs-number">2</span>;
        merge_sort(arr,low,mid);
        merge_sort(arr,mid+<span class="hljs-number">1</span>,high);
        merge(arr,low,high,mid);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>;
}
</div></code></pre>
<h4 id="413-%ec%a0%95%eb%a0%ac%ec%9d%98-%ed%95%98%ed%95%9c-lower-bound">4.1.3 정렬의 하한 Lower Bound</h4>
<p>배열의 원소를 비교하는 연산만으로는 <em>O(n log n)</em> 보다 빠르게 정렬할 수 없다.</p>
<h4 id="414-counting-sort">4.1.4 Counting Sort</h4>
<p>계수정렬(Counting Sort)은 배열의 원소를 직접 비교하지 않고 다른 정보를 이용하여 <em>O(n log n)</em> 이라는 하한이 적용되지 않는다. 이 알고리즘은 장부와 같은 배열을 사용하고 이 장부 배열의 인덱스가 원래 배열의 원소가 된다.
( 원래 배열의 원소가 0 ... c 범위의 정수 일 때만 사용 할 수 있다 )
이 알고리즘은 원래 배열에 1이라는 원소가 3번 들어있으면 장부 배열의 인덱스 1의 값을 3으로 등록하는 알고리즘으로 <em>O(n)</em> 시간 만이 걸린다.</p>
<h4 id="415-%ec%8b%a4%ec%a0%9c-%ec%83%81%ed%99%a9%ec%97%90%ec%84%9c%ec%9d%98-%ec%a0%95%eb%a0%ac">4.1.5 실제 상황에서의 정렬</h4>
<p>실제 상황에서는 정렬 알고리즘을 구현하지 않고 보통 라이브러리에 있는 정렬 함수를 사용한다.</p>
<pre><code class="language-cpp"><div><span class="hljs-comment">//일반적 벡터의 정렬</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vect = {<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>};
sort(vect.begin(),vect.end());
<span class="hljs-comment">//일반적 배열의 정렬</span>
<span class="hljs-keyword">int</span> arr[] = {<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>};
<span class="hljs-keyword">int</span> size=<span class="hljs-keyword">sizeof</span>(arr)/<span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]);
sort(arr,arr+size);
</div></code></pre>
<h5 id="%eb%b9%84%ea%b5%90-%ec%97%b0%ec%82%b0%ec%9e%90-comparison-operator">비교 연산자 (Comparison Operator)</h5>
<p>sort 함수를 사용할 때는 원소의 자료형에 대한 비교 연산자가 정의되어 있어야한다.
대부분의 C++ 자료형은 비교연산자가 정의되어있어 숫자는 크기, 문자열은 알파벳 순으로 정렬된다.
두 원소의 pair 의 경우는 첫 원소를 기준으로, 그 다음에는 두 번째 원소를 기준으로 정렬된다.</p>
<p>사용자 정의 구조체는 기본 비교 연산자가 없어 operator&lt; 형식으로 정의해야 한다.</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">myStruct</span> {</span>
    <span class="hljs-keyword">int</span> x,y;
    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> myStruct &amp;m){
        <span class="hljs-keyword">if</span>(x==m.x)<span class="hljs-keyword">return</span> y&lt;m.y;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> x&lt;m.x;
    }
}
</div></code></pre>
<h5 id="%eb%b9%84%ea%b5%90-%ed%95%a8%ec%88%98-comparison-function">비교 함수 (Comparison Function)</h5>
<p>외부에 정의한 비교 함수를 sort 함수에 콜백 형태로 넘길 수 있다.</p>
<pre><code class="language-cpp"><div>sort(vect.begin(),vect.end(),compare);
</div></code></pre>
<h3 id="42-%ec%a0%95%eb%a0%ac%ec%9d%84-%ec%9d%b4%ec%9a%a9%ed%95%9c-%eb%ac%b8%ec%a0%9c-%ed%92%80%ec%9d%b4">4.2 정렬을 이용한 문제 풀이</h3>
<p>정렬을 하면 효율을 좋게 설게 할 수 있는 알고리즘이 많다. 예를 들어, 한 배열의 모든 원소가 같은가를 검사하는 알고리즘은 이중 for문으로 모든 원소를 모든 원소와 비교하는 방식보다 그 배열을 정렬 한 뒤 옆의 원소와의 비교만을 하는 방식이 효율이 좋다.
( <em>O(n^2)</em> -&gt; <em>O(n)</em>)</p>
<h4 id="421-%ec%8a%a4%ec%9c%95-%eb%9d%bc%ec%9d%b8-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-sweep-line-algorithm">4.2.1 스윕 라인 알고리즘 (Sweep Line Algorithm)</h4>
<p>스윕 라인 알고리즘은 정렬된 순서대로 처리되는 이벤트의 집합으로 알고리즘을 모델링하는 방법이다.
예를 들어 가게에 손님이 한번에 가장 많은 경우 손님수의 최댓값을 구하는 문제가 있다면 입장을 시간순으로 정렬하여 손님의 입장과 퇴장에 따라 카운터로 둔 변수를 ++ -- 해주면 된다.</p>
<p>예를 들어 하루동안 가게에 손님들이 방문한 시간과 떠난 시간에 대한 정보가 있을 때, 동시에 손님이 가장 많은 시간을 구하는 문제를 해결한다고 하자.
이를 해결하기 위해 손님마다 방문과 떠남이라는 이벤트를 만들어 이의 시간을 정렬한 뒤 카운터 변수를 설정하여 손님이 방문하면 카운터++ 떠나면 카운터-- 로 문제를 해결할 수 있다.</p>
<h4 id="422-%ec%9d%b4%eb%b2%a4%ed%8a%b8-%ec%8a%a4%ec%bc%80%ec%a4%84%eb%a7%81">4.2.2 이벤트 스케줄링</h4>
<p>스케줄링 문제 중 입력 데이터를 정렬하고 탐역 알고리즘으로 해결 할 수 있는 문제가 많다.
예를 들어 시작 시간과 종료 시간이 정해져있는 이벤트가 여러개 주어지고 일정한 시간 내에 최대한 많은 이벤트를 처리 할 수 있는 스케줄을 만들고자 하는 문제가 있다.
이를 길이가 짧은 이벤트를 우선적으로 선택하거나 시작 시간이 빠른 이벤트를 우선적으로 선택하는 알고리즘을 구현하면 올바른 답을 구할 수 없지만, 이벤트 종료시간을 기준으로 정렬한 후 가장 먼저 종료하는 이벤트를 차례대로 선택하는 알고리즘을 사용하면 올바른 해를 구할 수 있다.</p>
<h3 id="43-%ec%9d%b4%ec%a7%84-%ed%83%90%ec%83%89">4.3 이진 탐색</h3>
<p>이진 탐색 (Binary Search) 는 정렬된 배열에 특정 원소가 존재하는지 파악 하는 문제를 해결하는 알고리즘인다. <em>O(log n)</em> 시간으로 해결된다.</p>
<h4 id="431-%ec%9d%b4%ec%a7%84-%ed%83%90%ec%83%89%ec%9d%98-%ea%b5%ac%ed%98%84">4.3.1 이진 탐색의 구현</h4>
<p>이진 탐색은 두가지 방법으로 구현할 수 있다.</p>
<ol>
<li>
<p>사전 탐색 방법
이진 탐색을 구현할 때 가장 많이 사용되는 방법으로 사전에서 단어를 찾는 방법과 유사하다.
처음에는 배열 전체를 가지고 가운데서 시작하여 찾는 값과 비교하여 배열의 원소값이 찾는 값보다 더 크면 부분 배열을 가운데에서 상한까지로 줄이는 식으로 진행한다.
구간이 반씩 줄어 log2 로 <em>O(log n)</em> 이 된다.</p>
<pre><code class="language-cpp"><div><span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;
<span class="hljs-keyword">while</span>(l&lt;=r){
    <span class="hljs-keyword">int</span> i=(l+r)/<span class="hljs-number">2</span>;
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[i]==x){
        <span class="hljs-comment">//찾았음 처리</span>
    }
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[i]&lt;x) l=k+<span class="hljs-number">1</span>;
    <span class="hljs-keyword">else</span> r=k<span class="hljs-number">-1</span>;
}
</div></code></pre>
</li>
<li>
<p>속도 제어 방법
두번째 방법은 배열을 왼쪽에서 오른쪽까지 건너뛰며 탐색하며 속도를 2분의1로 줄여가며 탐색하는 방법이다.
처음에는 배열 길이의 1/2 로 건너뛰며 탐색을 하여 오버슈팅하면 건너뛰지 않고 간격을 줄여 다시 탐색하는 방식이다.</p>
<pre><code class="language-cpp"><div><span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> r = n/<span class="hljs-number">2</span>; r&gt;=<span class="hljs-number">1</span>; r/=<span class="hljs-number">2</span> ){
    <span class="hljs-keyword">while</span> ( k+r&lt;n &amp;&amp; <span class="hljs-built_in">array</span>[k+r] &lt;= x) k += r;
}
<span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[k]==x){
    <span class="hljs-comment">//찾았음 처리</span>
}
</div></code></pre>
</li>
</ol>
<h4 id="432-%ec%b5%9c%ec%a0%81%ed%95%b4-%ea%b5%ac%ed%95%98%ea%b8%b0">4.3.2 최적해 구하기</h4>
<p>valid(x)라는 함수가 해가 k 일 때 x&lt;k 면 false, x&gt;=k면 true를 반환하는 함수 일 때, 이진 탐색으로 효율적으로 k를 구할수 있다.
false를 반환하는 최대의 x를 이진 탐색으로 구하는 원리이다.</p>
<pre><code class="language-cpp"><div><span class="hljs-keyword">int</span> x=<span class="hljs-number">-1</span>;
<span class="hljs-comment">//z는 최대값</span>
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = z; i&gt;=<span class="hljs-number">1</span>; i/=<span class="hljs-number">2</span>){
    <span class="hljs-keyword">while</span>(!valid(x+i)) x+=i;
}
<span class="hljs-keyword">int</span> k = x+<span class="hljs-number">1</span>;
</div></code></pre>
<h2 id="5%ec%9e%a5-%ec%9e%90%eb%a3%8c-%ea%b5%ac%ec%a1%b0">5장 자료 구조</h2>
<p>이장에서는 STL의 중요한 자료구조를 다룬다.</p>
<h3 id="51-%eb%8f%99%ec%a0%81-%eb%b0%b0%ec%97%b4">5.1 동적 배열</h3>
<p>일반적으로 크기가 고정인 C++ 배열과 달리 크기를 동적으로 할당할 수 있는 자료 구조를 살펴본다.</p>
<h4 id="511-%eb%b2%a1%ed%84%b0">5.1.1 벡터</h4>
<p>벡터는 배열의 끝에 원소를 추가하거나 삭제하는 과정을 효율적으로 할 수 있게 하는 동적 배열이다.</p>
<pre><code class="language-cpp"><div><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;
v.push_back(<span class="hljs-number">1</span>); <span class="hljs-comment">//[1]</span>
v.push_back(<span class="hljs-number">4</span>); <span class="hljs-comment">//[1,4]</span>
<span class="hljs-keyword">int</span> a = v.pop_back(); <span class="hljs-comment">//[1],a=4</span>
</div></code></pre>
<p>생성의 다른 방법도 있다.</p>
<pre><code class="language-cpp"><div><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v1(<span class="hljs-number">7</span>,<span class="hljs-number">4</span>); <span class="hljs-comment">//크기 7, 초깃값 4</span>
</div></code></pre>
<p>출력하는 방법:</p>
<pre><code class="language-cpp"><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v.size();i++) <span class="hljs-built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="hljs-string">"\n"</span>;
<span class="hljs-comment">// or</span>
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:v)<span class="hljs-built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="hljs-string">"\n"</span>;
</div></code></pre>
<h4 id="512-%eb%b0%98%eb%b3%b5%ec%9e%90%ec%99%80-%eb%b2%94%ec%9c%84">5.1.2 반복자와 범위</h4>
<p>반복자(Iterator)는 자료구조의 원소를 가리키는 변수이다.
begin 반복자는 첫번째 요소를 가리키고 end 반복자는 마지막 원소 다음을 가리킨다. (끝)
정렬을 벡터에 가하는 등에 사용 될 수 있다.</p>
<pre><code class="language-cpp"><div>sort(v.begin(),v.end());
</div></code></pre>
<p>유용한 함수로 정렬된 범위에서 원소가 x 이상인 첫 번째 원소를 가리키는 반복자를 반환하는 lower_bound 함수와 x 보다 큰 첫 번째 원소의 반복자를 반환하는 upper_bound 함수가 있다.</p>
<pre><code class="language-cpp"><div>sort(v.begin(),v.end());
<span class="hljs-keyword">auto</span> a = lower_bound(v.begin(),v.end(),<span class="hljs-number">5</span>);
</div></code></pre>
<h4 id="513-%eb%8b%a4%eb%a5%b8-%ec%9e%90%eb%a3%8c-%ea%b5%ac%ec%a1%b0">5.1.3 다른 자료 구조</h4>
<p>덱(Deque)은 양쪽 끝 원소를 처리할 수 있는 동적 배열이다. 벡터에 없는 push_front 와 pop_front 함수가 있다.</p>
<pre><code class="language-cpp"><div><span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt; d;
d.push_back(<span class="hljs-number">3</span>); <span class="hljs-comment">// [3]</span>
d.push_front(<span class="hljs-number">6</span>); <span class="hljs-comment">// [6,3]</span>
<span class="hljs-keyword">int</span> a = d.pop_front(); <span class="hljs-comment">// [3] , a=6</span>
</div></code></pre>
<p>스택(Stack)은 끝에서 원소를 넣고 빼는 push 와 pop 함수가 있다. top 함수는 마지막 원소를 반환한다.</p>
<p>큐(Queue)는 원소가 마지막에 추가되고 앞부터 삭제된다. (push, pop 함수) front 와 back 함수는 첫 원소와 마지막 원소를 반환한다.</p>
<h3 id="52-%ec%a7%91%ed%95%a9-%ec%9e%90%eb%a3%8c-%ea%b5%ac%ec%a1%b0">5.2 집합 자료 구조</h3>
<p>셋(Set, 집합)은 원소의 집합을 구현하는 자료구조이다. 기본적 연산은 추가, 탐색, 삭제이다.</p>
<h4 id="521-%ec%85%8b%ea%b3%bc-%eb%a9%80%ed%8b%b0%ec%85%8b">5.2.1 셋과 멀티셋</h4>
<p>c++ STL에는 집합 자료구조가 두가지 있다.
-set은 이진 탐색 트리를 기반으로 만들어져 있다.
-unordered_set은 해시 테이블을 기반으로 만들어져 있다.</p>
<pre><code class="language-cpp"><div><span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; s;
s.insert(<span class="hljs-number">3</span>);
s.insert(<span class="hljs-number">3</span>); <span class="hljs-comment">//이미 있으면 추가되지 않음</span>
s.insert(<span class="hljs-number">4</span>);
<span class="hljs-built_in">cout</span>&lt;&lt;s.count(<span class="hljs-number">3</span>)&lt;&lt;<span class="hljs-string">"\n"</span>; <span class="hljs-comment">// 1</span>
s.erase(<span class="hljs-number">3</span>);
</div></code></pre>
<p>set은 일반적인 집합의 형태로 모든 원소가 서로 다르며 개수는 1보다 올라가지 않는다. (count는 항상 0 혹은 1을 반환.) 같은 원소의 중복을 허용하는 자료구조는 멀티셋이있다.
set은 대괄호 [] 로 원소에 접근 할 수 없다.
size로 크기를 확인 할 수 있다.
find(x)는 값이 x 인 원소를 가리키는 반복자를 반환한다. 원소가 없는경우에는 end()를 반환한다.</p>
<pre><code class="language-cpp"><div><span class="hljs-keyword">auto</span> it = s.find(x);
<span class="hljs-keyword">if</span>(it==s.end()){
    <span class="hljs-comment">//x가 s에 없다</span>
}
</div></code></pre>
<p>가장 큰 c++ STL 집합의 차이는 set은 정렬되어있고 unordered_set은 그렇지 않다.</p>
<p>멀티셋은 같은값을 여러개 가질 수 있는 집합이다. multiset 과 unordered_multiset이 있다.</p>
<h4 id="522-%eb%a7%b5">5.2.2 맵</h4>
<p>맵(Map)은 키와 쌍을 저장하는 집합이다.</p>
<pre><code class="language-cpp"><div><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-keyword">int</span>&gt; m;
m[<span class="hljs-string">"monkey"</span>]=<span class="hljs-number">5</span>; 
</div></code></pre>
<h4 id="523-%ec%9a%b0%ec%84%a0%ec%88%9c%ec%9c%84%ed%81%90">5.2.3 우선순위큐</h4>
<p>우선순위 큐(Priority Queue)는 원소의 추가, 탐색, 그리고 삭제가 되는 멀티셋이다.
우선순위 큐는 특별한 형태의 이진 트리인 힙(heap)을 기반으로 한다.
(push,pop,top)</p>
<h2 id="6%ec%9e%a5--%eb%8f%99%ec%a0%81-%ea%b3%84%ed%9a%8d%eb%b2%95-dynamic-programming">6장 : 동적 계획법 Dynamic Programming</h2>
<p>동적 계획법 (Dynamic Programming)은 문제의 최적해를 구하거나 만족하는 경우의 수를 구하는 과정 등에서 사용할 수 있는 알고리즘 기법이다.
이장에서는 동적 계획법의 기본 요소를 살피고 예시를 본다.</p>
<h4 id="611-%ed%83%90%ec%9a%95%eb%b2%95%ec%9d%b4-%ec%8b%a4%ed%8c%a8%ed%95%98%eb%8a%94-%ea%b2%bd%ec%9a%b0">6.1.1 탐욕법이 실패하는 경우</h4>
<p>동전 교환 문제로 동적 계획법의 기본을 살펴본다.
여러 돈전의 값 coins[] = {c1,c2,...} 가 있고 만들어야하는 목표 액수 n 이 주어져, 최소한의 개수의 동전으로 합이 n 이 되도록 해야 한다.</p>
<p>ex) coins = [1,2,5] , n = 12 면 5 + 5 + 2 = 12 로 답은 3인 된다.</p>
<p>하지만 이때 탐욕 알고리즘으로 최대한 큰 동전을 우선적으로 쓴다고 항상 답이 나오지는 않는다.</p>
<p>ex) coins = [1,3,4] , n = 6 이면 탐욕알고리즘으로는 4 + 1 + 1 로 6이 되지만 실제 정답은 3 + 3 으로 2이다.</p>
<h4 id="612-%ec%b5%9c%ec%a0%81%ed%95%b4-%ea%b5%ac%ed%95%98%ea%b8%b0">6.1.2 최적해 구하기</h4>
<p>동적 계획법을 사용하기 위해 재귀적인 구조나 반복문을 이용한 구현으로 점화식을 사용해야한다.
위의 예시의 문제로 보면</p>
<pre><code class="language-cpp"><div>solve(x) = min(
    solve(x<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>,
    solve(x<span class="hljs-number">-3</span>)+<span class="hljs-number">1</span>,
    solve(x<span class="hljs-number">-4</span>)+<span class="hljs-number">1</span>)
</div></code></pre>
<p>이 점화식이 된다.</p>
<p>이를 재귀적으로 구현하면 Top Down 으로 풀 수 있다.</p>
<pre><code class="language-cpp"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; coins)</span></span>{
    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> INT_MAX;
    <span class="hljs-keyword">if</span>(x=<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> minimum = INT_MAX;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;coins.size();i++){
        minimum = min(minimum,solve(s-coins[i])+<span class="hljs-number">1</span>);
    }
    <span class="hljs-keyword">return</span> minimum;
}
</div></code></pre>
<p>이를 이미 게산한 값을 저장하는 메모화 (Memoization)을 이용하여 더 효율적으로 만들 수 있다.</p>
<pre><code class="language-cpp"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; coins)</span></span>{
    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> INT_MAX;
    <span class="hljs-keyword">if</span>(x=<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span>(memo[x]) <span class="hljs-keyword">return</span> memo[x];

    <span class="hljs-comment">// ...</span>

}
</div></code></pre>
<p>재귀보다는 반복문을 이용한 해결이 더 효율적이라 선호된다.</p>
<pre><code class="language-cpp"><div>value[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>; x&lt;=n; x++){
    value[x]=INT_MAX;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;coins.size();i++){
        value[x] = min(value[x],value[x-coins[i]]+<span class="hljs-number">1</span>);
    }
}

</div></code></pre>
<h4 id="613-%ed%95%b4%ec%9d%98-%ea%b0%9c%ec%88%98-%ec%84%b8%ea%b8%b0">6.1.3 해의 개수 세기</h4>
<p>동전 문제를 변형하여 금액을 표현할 수 있는 동전의 수열의 개수를 구하는 문제로 만들수 있다.
이는 solve(x) = solve(x-1) + solve(x-3) + solve(x-4) 로 구현할 수 있다.
값이 너무 커져 modular 연산을 해야하는 경우 미리 modular을 적용하여도 된다.</p>
<pre><code class="language-cpp"><div><span class="hljs-built_in">cout</span>[x] += count[x<span class="hljs-number">-1</span>] +  count[x<span class="hljs-number">-3</span>] + count[x<span class="hljs-number">-4</span>]; 
count[x] %= m;
</div></code></pre>
<h3 id="62-%eb%8b%a4%eb%a5%b8-%ec%98%88%ec%a0%9c">6.2 다른 예제</h3>
<h4 id="621-%ec%b5%9c%ec%9e%a5-%ec%a6%9d%ea%b0%80-%eb%b6%80%eb%b6%84-%ec%88%98%ec%97%b4-longest-increasing-subsequence">6.2.1 최장 증가 부분 수열 (Longest Increasing Subsequence)</h4>
<p>{6,2,5,1,7,4,8,3} 이라는 수열이 있을때, 이 수열의 최장 증가 부분 수열은
{2,5,7,8} 이다.</p>
<p>이를 동적 계획법으로 <em>O(n^2)</em> 시간에 해결 할 수 있다.</p>
<p>length(k)를 인덱스 k에서 끝나는 최장 증가 부분 수열의 길이로 하면
length(k)는 array[i]&lt;array[k] (증가 조건) 이면서 length(i)가 최대인 위치 i&lt;k를 찾아야한다. (최장 조건)
이러면 length(k)=length(i)+1 이 되어야하는데, 이는 i에서 끝나는 최장 증가 부분 수열의 마지막에 array[k]를 추가하는게 최선이기 때문이다.
이를 만족시키는 i가 없다면 length(k)=1 로 k에서 시작하는 부분 배열을 새로 열어준다.</p>
<pre><code class="language-cpp"><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>; k&lt;n; k++){
    length[k]=<span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;k; i++){
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>[i]&lt;<span class="hljs-built_in">array</span>[k]){
            length[k]=max(length[k],length[i]+<span class="hljs-number">1</span>);
        }
    })
}
</div></code></pre>
<p>이 문제를 <em>O(n^2)</em> 이 아닌 <em>O(n log n)</em> 으로 푸는 방법이 있다.
이는 이중 for 문이 아닌 처리하는 경우의 수를 나누어 탐색으로 푸는 방법이다.
다음과 같은 조건을 사용하여 코드를 구현하면 탐색시간인 <em>O(n log n)</em> 에 코드가 작동한다.</p>
<ol>
<li>
<p>array[i]가 후보 리스트의 말단에 올 수 있는 원소 중 가장 작으면, array[i]로 시작하는 길이 1의 새로운 리스트를 생성한다.</p>
</li>
<li>
<p>array[i]가 후보 리스트의 말단에 올 수 있는 원소 중 가장 크면, 가장 큰 후보 리스트를 복사하고 array[i]를 추가해 연장한다.</p>
</li>
<li>
<p>array[i]가 그 사이라면, array[i]보다 말단 원소가 작은 리스트를 찾아 (탐색) 이를 복사하고 array[i]를 추가해 연장한다.
같은 길이의 다른 후보 리스트는 모두 삭제한다.</p>
</li>
</ol>
<h2 id="7%ec%9e%a5-%ea%b7%b8%eb%9e%98%ed%94%84-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98">7장 그래프 알고리즘</h2>
<p>7장에서는 주어진 상황을 그래프로 표현하여 적절한 그래프 알고리즘을 이용하여 해결함을 살펴 볼 것이다.</p>
<h3 id="71-%ea%b7%b8%eb%9e%98%ed%94%84%ec%9d%98-%ea%b8%b0%eb%b3%b8">7.1 그래프의 기본</h3>
<h4 id="711-%ea%b7%b8%eb%9e%98%ed%94%84-%ec%9a%a9%ec%96%b4">7.1.1 그래프 용어</h4>
<p>그래프 (Graph) 는 노드 (Node) 혹은 정점 (Vertex, Verticies) 와 그를 잇는 간선 (edge) 로 구성된다.</p>
<p>경로 (Path)는 한 노드에서 그래프의 간선을 지나 다른 노드까지 가는 길을 뜻한다.</p>
<p>사이클은 (Cycle)은 처음 노드와 마지막 노드가 같은 경로를 의미한다.</p>
<p>그래프의 모든 노드간 경로가 있는 경우 연결 그래프 (Connected Graph)라 한다.</p>
<p>그래프의 연결된 한 부분을 컴포넌트 (Component)라고 한다.</p>
<p>트리 (Tree)는 사이클이 없는 연결 그래프이다. (필요충분조건)</p>
<p>방향 그래프 (Directed Graph)는 간선의 한 방향으로만 이동할 수 있는 그래프이다.</p>
<p>가중 그래프 (Weighted Graph)는 간선마다 가중치 (weight)가 있는 그래프이다.</p>
<p>두 노드를 잇는 간선이 있을 때 두 노드를 이웃 (neighbor), 혹은 인접한 노드 (adjacent node)라 한다.</p>
<p>노드의 이웃 노드의 개수를 노드의 차수 (degree)라 한다.</p>
<p>간선 개수가 m 일때 모든 노드의 차수의 합은 2m 이 된다. (직관적)</p>
<p>모든 노드의 차수가 동일한 경우 정규 그래프 (Regular Graph)라 하고</p>
<p>모든 노드의 차수가 n-1 로 다른 모든 노드와 연결된 경우 완전 그래프 (Complete Graph)라 한다.</p>
<p>노드로 들어오는 간선의 개수와 나가는 간선의 개수를 진입 차수 (indegree) 와 진출 차수 (outdegree)라 한다.</p>
<p>그래프의 노드를 두 색으로 칠할 때 이웃한 노드와 같은 색이 되지 않도록 하는 그래프를 이분 그래프 (Bipartite Graph)라 한다.</p>
<h4 id="712-%ea%b7%b8%eb%9e%98%ed%94%84%ec%9d%98-%ed%91%9c%ed%98%84">7.1.2 그래프의 표현</h4>
<p>그래프를 알고리즘에서 표현하는 방법을 알아본다. 그래프의 크기와 알고리즘에서 그래프를 처리하는 방법에 따라 사용될 자료구조가 결정된다.</p>
<h4 id="%ec%9d%b8%ec%a0%91-%eb%a6%ac%ec%8a%a4%ed%8a%b8-adjacency-list">인접 리스트 (Adjacency List)</h4>
<p>인접 리스트는 그래프의 각 노드 x에 대한 인접 리스트를 관리한다. (x에서 출발하여 그 노드에 도착하는 간선이 있는 노드의 리스트)
인접 리스트가 그래프를 나타내는 가장 대표적인 방법으로 대부분의 그래프 알고리즘에서 활용한다.
인접 리스트는 벡터의 배열 혹은 배열의 배열을 이용해 구현하여 저장할 수 있다.</p>
<pre><code class="language-cpp"><div><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; adjacencyList[N];

adjacencyList[<span class="hljs-number">1</span>].push_back(<span class="hljs-number">2</span>); <span class="hljs-comment">//1-&gt;2 edge 있다는 뜻</span>
</div></code></pre>
<p>무방향 그래프는 각각의 간선이 양방향에 대해 저장되면 된다.</p>
<p>가중 그래프는 값을 추가하여 확장하면 된다.</p>
<pre><code class="language-cpp"><div><span class="hljs-built_in">vector</span>&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; adj[N];
</div></code></pre>
<p>이런 경우 인접 리스트에는 (b,w)로 값이 저장되어 b로 향하는 간선이 w의 가중치를 갖는다는 의미가 된다.</p>
<p>인접 리스트를 사용하면 주어진 노드에서 출발하여 갈 수 있는 노드를 효율적으로 처리할 수 있다.</p>
<pre><code class="language-cpp"><div><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : adj[s]){
    <span class="hljs-comment">//노드 처리</span>
}
</div></code></pre>
<h4 id="%ec%9d%b8%ec%a0%91-%ed%96%89%eb%a0%ac-adjacency-matrix">인접 행렬 (Adjacency Matrix)</h4>
<p>그래프에 포함된 간선을 나타내는 행렬을 인접 행렬이라 한다.
인접 행렬은 두 노드 사이에 간선이 있는지를 효율적으로 확인 할 수 있도록 한다.
행렬의 인덱스 [m][n]에 1이 있으면 m-&gt;n 으로 향하는 간선이 있는것이다.</p>
<pre><code class="language-cpp"><div><span class="hljs-keyword">int</span> adj[N][N];
</div></code></pre>
<p>ex)
0 1 0 0
0 0 1 0
1 1 0 0
0 0 0 1</p>
<h4 id="%ea%b0%84%ec%84%a0-%eb%a6%ac%ec%8a%a4%ed%8a%b8-edge-list">간선 리스트 (Edge List)</h4>
<p>간선 리스트는 그래프의 모든 간선을 특정한 순서에 따라 저장한 리스트이다.
특정한 노드에서 출발하는 간선보다 모든 간선을 살펴보는 형태를 필요로 할때 유용하다.</p>
<pre><code class="language-cpp"><div><span class="hljs-built_in">vector</span>&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; edges;

edges.push_back({<span class="hljs-number">1</span>,<span class="hljs-number">2</span>}); <span class="hljs-comment">//1-&gt;2 edge 추가</span>
</div></code></pre>
<p>가중 그래프는 다음과 같이 구현할 수 있다.</p>
<pre><code class="language-cpp"><div><span class="hljs-built_in">vector</span>&lt;tuple&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; edges;
</div></code></pre>
<h3 id="72-%ea%b7%b8%eb%9e%98%ed%94%84-%ec%88%9c%ed%9a%8c">7.2 그래프 순회</h3>
<p>깊이 우선 탐색 (DFS : Depth First Search) 과 너비 우선 탐색 (BFS: Breadth First Search) 알고리즘을 알아본다.</p>
<h4 id="721-%ea%b9%8a%ec%9d%b4-%ec%9a%b0%ec%84%a0-%ed%83%90%ec%83%89-dfs">7.2.1 깊이 우선 탐색 (DFS)</h4>
<img src="https://he-s3.s3.amazonaws.com/media/uploads/9fa1119.jpg" width="200" height="150"/>
<p>재귀적 알고리즘으로 간단히 구현 할 수 있다.</p>
<pre><code class="language-cpp"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100</span>

<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; adj[N]; <span class="hljs-comment">//adjacency list</span>
<span class="hljs-keyword">bool</span> visited[N];

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>{
    <span class="hljs-keyword">if</span> (visited[i]=<span class="hljs-literal">true</span>) <span class="hljs-keyword">return</span>;
    visited[s] = <span class="hljs-literal">true</span>;
    <span class="hljs-comment">// 해당 노드 i 처리</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> u = adj[s]){ <span class="hljs-comment">//간선타고 들어가서 노드 처리</span>
        dfs(u);
    }
}
</div></code></pre>
<h4 id="722-%eb%84%88%eb%b9%84-%ec%9a%b0%ec%84%a0-%ed%83%90%ec%83%89-bfs">7.2.2 너비 우선 탐색 (BFS)</h4>
<p>너비 우선 탐색은 시작 노드에서 거리가 증가하는 순서대로 노드들을 방문한다.</p>
<img src="https://he-s3.s3.amazonaws.com/media/uploads/fdec3c2.jpg" width="200" height="120">

    </body>
    </html>