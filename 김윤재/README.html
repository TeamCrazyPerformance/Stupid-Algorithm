<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>*알고리즘 트레이닝* 의 정리</title>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        
    </head>
    <body class="vscode-light">
        <h1 id="%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%ed%8a%b8%eb%a0%88%ec%9d%b4%eb%8b%9d-%ec%9d%98-%ec%a0%95%eb%a6%ac"><em>알고리즘 트레이닝</em> 의 정리</h1>
<h3 id="guide-to-competitive-programming-learning-and-improving-algorithms-through-contests-by-antti-laaksonen">( <em>Guide to Competitive Programming: Learning and Improving Algorithms Through Contests</em> by Antti Laaksonen )</h3>
<h2 id="1%ec%9e%a5-%ec%83%9d%eb%9e%b5">1장 생략</h2>
<h2 id="2%ec%9e%a5--%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%b0%8d-%ea%b8%b0%eb%b2%95-programming-techniques">2장 : 프로그래밍 기법 <em>Programming Techniques</em></h2>
<p>이 장은 C++ 프로그래밍의 특징, 재귀, 비트연산을 다룬다.</p>
<h4 id="21-%ec%96%b8%ec%96%b4%ec%a0%81-%ed%8a%b9%ec%84%b1-language-features">2.1 언어적 특성 <em>Language Features</em></h4>
<p>표쥰적 경진 프로그래밍 코드 형태 :</p>
<pre><code class="language-cpp"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits.stdc++&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">//code</span>
}
</div></code></pre>
<p>&lt;bits.stdc++&gt; 은 표준 라이브러리 전체를 포함한다. (iostream, vector, algrotihm 등 포함)</p>
<h5 id="211-%ec%9e%85%eb%a0%a5%ea%b3%bc-%ec%b6%9c%eb%a0%a5">2.1.1 입력과 출력</h5>
<ul>
<li>
<p>표준 stream 으로 입출력 처리한다.</p>
<pre><code class="language-cpp"><div><span class="hljs-keyword">int</span> a,b;
<span class="hljs-built_in">string</span> str;
<span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;str;
</div></code></pre>
<p>개행이나 공백으로 입력 분리된다.</p>
</li>
<li>
<p>간혹 입출력이 프로그램의 병목이 될 때가 있으면 아래와 같이 처리한다.</p>
</li>
</ul>
<pre><code class="language-cpp"><div>ios::sync_with_stdio(<span class="hljs-number">0</span>); <span class="hljs-comment">//standard stream synch -&gt; false</span>
<span class="hljs-built_in">cin</span>.tie(<span class="hljs-number">0</span>); <span class="hljs-comment">//unties cin from cout</span>
</div></code></pre>
<ul>
<li>
<p>endl 보다 &quot;\n&quot; 이 더 빠르다.</p>
</li>
<li>
<p>데이터 양을 모를때 반복문으로 처리한다. 하나씩 읽어 들이다 데이터가 없을 때 멈춘다.</p>
</li>
</ul>
<pre><code class="language-cpp"><div><span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;x){
<span class="hljs-comment">//code</span>
}
</div></code></pre>
<ul>
<li>데이터가 파일로 주어지면 평소처럼 표준 스트림을 이용하는 방법은 입력이 input.txt, 출력을 output.txt로 할때 다음과 같다.</li>
</ul>
<pre><code class="language-cpp"><div>freopen(<span class="hljs-string">"input.txt"</span>,<span class="hljs-string">"r"</span>,<span class="hljs-built_in">stdin</span>);
freopen(<span class="hljs-string">"output.txt"</span>,<span class="hljs-string">"w"</span>,<span class="hljs-built_in">stdout</span>);
</div></code></pre>
<h5 id="212-%ec%88%98%ec%9d%98-%ec%b2%98%eb%a6%ac">2.1.2 수의 처리</h5>
<ul>
<li>정수의 처리
알고리즘 경진에서 int의 범위(최대 2^31-1)를 벗어나게 되는 큰 수는 보통 long long으로 처리하게 된다. 이때 조심해야 할 버그가 있다.</li>
</ul>
<pre><code class="language-cpp"><div><span class="hljs-keyword">int</span> x = <span class="hljs-number">6666666666</span>;
<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> y = x*x;
<span class="hljs-built_in">cout</span>&lt;&lt;y&lt;&lt;<span class="hljs-string">"\n"</span>; <span class="hljs-comment">//Overflows.</span>
</div></code></pre>
<p>이는 y의 자료형이 long long이지만 x*x에 포함된 수의 자료형이 int로 결과도 int로 처리되기 때문이다.</p>
<pre><code class="language-cpp"><div><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> y = (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)x*x;
</div></code></pre>
<p>로 바꾸어주면 된다.</p>
<ul>
<li>나머지 연산
나머지 (Modulo) 연산은 (a+b) mod m = ( (a mod m) + (b mod m) ) mod m 을 만족한다. 이를 이용하여 값을 작게 유지하기 위해 연산을 수행할 때마다 mod를 취해 주면 된다.
예를 들어 n!을 m으로 나눈 나머지를 구하는 코드가 있다.</li>
</ul>
<pre><code class="language-cpp"><div><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x=<span class="hljs-number">1</span>;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) x=(x*i)%m;
<span class="hljs-built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="hljs-string">"\n"</span>&gt;&gt;;
</div></code></pre>
<p>C++ 언어가 음수의 나머지를 음수로 취급함에 따라 음수면 m을 더해주면 된다.</p>
<pre><code class="language-cpp"><div><span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) x += m;
</div></code></pre>
<ul>
<li>부동 소수점 실수 (float, double)
long double이 정밀도가 높아 사용하기 좋다. 부동 소수점 오차는 == 연산자를 사용하지 않고 두 수의 차이가 ε 이하로 처리하여 사용할 수 있다. 출력도 다음과 같이 할 수 있다.\</li>
</ul>
<pre><code class="language-cpp"><div><span class="hljs-keyword">double</span> b=<span class="hljs-number">0.7</span>*<span class="hljs-number">3</span><span class="hljs-number">-1.1</span>;
<span class="hljs-keyword">double</span> a=<span class="hljs-number">0.3</span>*<span class="hljs-number">3</span>+<span class="hljs-number">0.1</span>;
<span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(a-b)&lt;<span class="hljs-number">1e-9</span>){ <span class="hljs-comment">// ε = 10^-9</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.20f\n"</span>,a);  
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.20f\n"</span>,b); 
<span class="hljs-comment">// a,b 값은 오차로 미묘하게 다르다.</span>
}
</div></code></pre>
<h5 id="213-%ec%a7%a7%ec%9d%80-%ec%bd%94%eb%93%9c">2.1.3 짧은 코드</h5>
<ul>
<li>자료형
typedef 로 자료형을 짧게 줄일 수 있다.</li>
</ul>
<pre><code class="language-cpp"><div><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;
</div></code></pre>
<ul>
<li>매크로
선처리 #define 으로 매크로를 정의할 수 있다.</li>
</ul>
<pre><code class="language-cpp"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> F first</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SWAP(x, y, T) do { T SWAP = x; x = y; y = SWAP; } while (0)</span>
</div></code></pre>
<p>SWAP 매크로는 타입을 사용해서</p>
<pre><code class="language-cpp"><div>SWAP(a, b, <span class="hljs-keyword">int</span>);
</div></code></pre>
<h4 id="22-%ec%9e%ac%ea%b7%80%ec%a0%81-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98">2.2 재귀적 알고리즘</h4>
<h5 id="221-%eb%b6%80%eb%b6%84%ec%a7%91%ed%95%a9-%ec%83%9d%ec%84%b1%ed%95%98%ea%b8%b0">2.2.1 부분집합 생성하기</h5>
<p>원소가 n개인 집합의 부분집합을 모두 생산하는 알고리즘을 재귀로 구현한다.
하나의 원소씩 포함하거나 제외하는 2^n 번의 과정을 재귀로 구현하기 좋다.</p>
<pre><code class="language-cpp"><div>
</div></code></pre>
<h5 id="222-%ec%88%9c%ec%97%b4--permutations">2.2.2 순열 ( Permutations )</h5>
<h5 id="223-%ed%87%b4%ea%b0%81-%ea%b2%80%ec%83%89--backtracking">2.2.3 퇴각 검색 ( Backtracking )</h5>
<h4 id="23-%eb%b9%84%ed%8a%b8-%ec%97%b0%ec%82%b0">2.3 비트 연산</h4>
<h2 id="3%ec%9e%a5--%ed%9a%a8%ec%9c%a8%ec%84%b1">3장 : 효율성</h2>
<p>이 장은 알고리즘의 시간 복잡도를 다루어 알고리즘의 효율성을 다룬다.</p>
<h4 id="31-%ec%8b%9c%ea%b0%84-%eb%b3%b5%ec%9e%a1%eb%8f%84">3.1 시간 복잡도</h4>
<h4 id="32">3.2</h4>

    </body>
    </html>