<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>*알고리즘 트레이닝* 의 정리</title>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        
    </head>
    <body class="vscode-light">
        <h1 id="%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%ed%8a%b8%eb%a0%88%ec%9d%b4%eb%8b%9d-%ec%9d%98-%ec%a0%95%eb%a6%ac"><em>알고리즘 트레이닝</em> 의 정리</h1>
<h3 id="guide-to-competitive-programming-learning-and-improving-algorithms-through-contests-by-antti-laaksonen">( <em>Guide to Competitive Programming: Learning and Improving Algorithms Through Contests</em> by Antti Laaksonen )</h3>
<h2 id="1%ec%9e%a5-%ec%83%9d%eb%9e%b5">1장 생략</h2>
<h2 id="2%ec%9e%a5--%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%b0%8d-%ea%b8%b0%eb%b2%95-programming-techniques">2장 : 프로그래밍 기법 <em>Programming Techniques</em></h2>
<p>이 장은 C++ 프로그래밍의 특징, 재귀, 비트연산을 다룬다.</p>
<h4 id="21-%ec%96%b8%ec%96%b4%ec%a0%81-%ed%8a%b9%ec%84%b1-language-features">2.1 언어적 특성 <em>Language Features</em></h4>
<p>표쥰적 경진 프로그래밍 코드 형태 :</p>
<pre><code><code><div>#include &lt;bits.stdc++&gt;
using namespace std;
int main(){
    //code
}
</div></code></code></pre>
<p>&lt;bits.stdc++&gt; 은 표준 라이브러리 전체를 포함한다. (iostream, vector, algrotihm 등 포함)</p>
<h5 id="211-%ec%9e%85%eb%a0%a5%ea%b3%bc-%ec%b6%9c%eb%a0%a5">2.1.1 입력과 출력</h5>
<pre><code>    - 표준 stream 으로 입출력 처리한다. 
    ```cpp
    int a,b;
    string str;
    cin&gt;&gt;a&gt;&gt;b&gt;&gt;str;
    ```
    개행이나 공백으로 입력 분리된다.

    - 간혹 입출력이 프로그램의 병목이 될 때가 있으면 아래와 같이 처리한다.
    ```cpp
    ios::sync_with_stdio(0); //standard stream synch -&gt; false
    cin.tie(0); //unties cin from cout
    ```

    - endl 보다 &quot;\n&quot; 이 더 빠르다.
    
    - 데이터 양을 모를때 반복문으로 처리한다. 하나씩 읽어 들이다 데이터가 없을 때 멈춘다.
    ```cpp
    while(cin&gt;&gt;x){
        //code
    }
    ```
    - 데이터가 파일로 주어지면 평소처럼 표준 스트림을 이용하는 방법은 입력이 input.txt, 출력을 output.txt로 할때 다음과 같다.
    ```cpp
    freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);
    freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout);
    ```
</code></pre>
<h5 id="212-%ec%88%98%ec%9d%98-%ec%b2%98%eb%a6%ac">2.1.2 수의 처리</h5>
<pre><code>    - 정수의 처리
    알고리즘 경진에서 int의 범위(최대 2^31-1)를 벗어나게 되는 큰 수는 보통 long long으로 처리하게 된다. 이때 조심해야 할 버그가 있다.
    ```cpp
    int x = 6666666666;
    long long y = x*x;
    cout&lt;&lt;y&lt;&lt;&quot;\n&quot;; //Overflows.
    ```
    이는 y의 자료형이 long long이지만 x*x에 포함된 수의 자료형이 int로 결과도 int로 처리되기 때문이다.
    ```cpp
    long long y = (long long)x*x;
    ```
    로 바꾸어주면 된다.

    - 나머지 연산
    나머지 (Modulo) 연산은 (a+b) mod m = ( (a mod m) + (b mod m) ) mod m 을 만족한다. 이를 이용하여 값을 작게 유지하기 위해 연산을 수행할 때마다 mod를 취해 주면 된다.
    예를 들어 n!을 m으로 나눈 나머지를 구하는 코드가 있다.
    ```cpp
    long long x=1;
    for(int i=1;i&lt;=n;i++) x=(x*i)%m;
    cout&lt;&lt;x&lt;&lt;&quot;\n&quot;&gt;&gt;;
    ```
    C++ 언어가 음수의 나머지를 음수로 취급함에 따라 음수면 m을 더해주면 된다.
    ```cpp
    if(x&lt;0) x += m;
    ```

    - 부동 소수점 실수 (float, double) 
    long double이 정밀도가 높아 사용하기 좋다. 부동 소수점 오차는 == 연산자를 사용하지 않고 두 수의 차이가 ε 이하로 처리하여 사용할 수 있다. 출력도 다음과 같이 할 수 있다.\
    ```cpp
    double b=0.7*3-1.1;
    double a=0.3*3+0.1;
    if(abs(a-b)&lt;1e-9){ // ε = 10^-9
    printf(&quot;%.20f\n&quot;,a);  
    printf(&quot;%.20f\n&quot;,b); 
    // a,b 값은 오차로 미묘하게 다르다.
    }
    ```
</code></pre>
<h5 id="213-%ec%a7%a7%ec%9d%80-%ec%bd%94%eb%93%9c">2.1.3 짧은 코드</h5>
<pre><code>    - 자료형
    typedef 로 자료형을 짧게 줄일 수 있다.
    ```cpp
    typedef long long ll;
    ```

    - 매크로
    선처리 #define 으로 매크로를 정의할 수 있다.
    ```cpp
    #define F first
    #define SWAP(x, y, T) do { T SWAP = x; x = y; y = SWAP; } while (0)
    ```
    SWAP 매크로는 타입을 사용해서
    ```cpp
    SWAP(a, b, int);
    ```
</code></pre>
<h4 id="22-%ec%9e%ac%ea%b7%80%ec%a0%81-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98">2.2 재귀적 알고리즘</h4>
<h5 id="221-%eb%b6%80%eb%b6%84%ec%a7%91%ed%95%a9-%ec%83%9d%ec%84%b1%ed%95%98%ea%b8%b0">2.2.1 부분집합 생성하기</h5>
<pre><code>    원소가 n개인 집합의 부분집합을 모두 생산하는 알고리즘을 재귀로 구현한다.
    ```cpp
    
    ```
</code></pre>
<h5 id="222-%ec%88%9c%ec%97%b4--permutations">2.2.2 순열 ( Permutations )</h5>
<h5 id="223-%ed%87%b4%ea%b0%81-%ea%b2%80%ec%83%89--backtracking">2.2.3 퇴각 검색 ( Backtracking )</h5>
<h4 id="23-%eb%b9%84%ed%8a%b8-%ec%97%b0%ec%82%b0">2.3 비트 연산</h4>
<h2 id="3%ec%9e%a5--%ed%9a%a8%ec%9c%a8%ec%84%b1-programming-techniques">3장 : 효율성 <em>Programming Techniques</em></h2>

    </body>
    </html>