# Chapter14; 문자열 알고리즘

## 14.1 기본 주제
부분 문자열(substring) : 원본 문자열에서 연속된 글자가 나열된 형태. s[a..b]는 문자열 s에서 위치 a부터 b까지 연속된 문자의 집합이다.
접두사(prefix) : 문자열의 첫 번째 글자를 포함한 부분 문자열
접미사(suffix) : 문자열의 마지막 글자를 포함한 부분 문자열  
부분 수열(subsequence) : 일정한 순서를 가지고 나열된 형태, 부분 문자열은 부분 수열이지만, 부분 수열은 부분 문자열이 될 수 없다.  

### 14.1.1 트라이 자료 구조
트라이(trie)는 문자열의 집합을 관리하는 루트 트리이다.  
집합의 각 문자열은 루트 노드에서 시작하는 글자 경로의 형태로 저장되는데 주어진 문자열이 트라이에 포함되는지 찾으려면 루트 노드에서부터 탐색을 하면된다.  
`int trie[N][A]`의 형태로 저장할 수 있으며 N은 노드의 최대 개수, A는 주어진 알파벳 개수로 선정된다.  
`trie[s][c]`는 s번째 노드에서 글자 c를 따라가면 나올 수 있는 노드를 return 한다. 만약 갈 수 없다면 0을 return 한다.  

### 14.1.2 동적 계획법
동적 계획법을 이용하여 문자열 문제를 해결 할 수 있다. 예제 2개를 살펴보자.  

#### 최장 공통 부분 수열
최장 공통 부분 수열은 두 문자열의 부분 수열이 되는 문자열 중 가장 긴 것을 선택하는 것이다.  
TOUR와 OPERA에서는 OR이 최장 공통 부분 수열이 될 수 있다.  
점화식은 아래와 같다.  
```
lcs(i,j) = lcs(i-1, j-1) + 1 (x[i] = y[j])
lcs(i,j) = max(lcs(i,j-1), lcs(i-1,j)) (x[i]!=y[j])
```
> 이해는 했는데 설명하기 .. 음..  

#### 편집 거리
두 문자열의 편집거리(레벤슈타인 거리)는 첫 번째 문자열을 두 번째 문자열로 변환하기 위해 필요한 편집 연산 최소 횟수이다.  
삽입하거나, 삭제하거나, 수정하는 것만 허용이 된다.  
edit(i,j)를 x[0~i], y[0~j]의 편집 거리라 했을 경우에는 경우의 수는 아래와 같다.  
만약 x[i]와 y[j]가 같다면 편집거리는 edit(i-1, j-1)과 같을 것이다.(이전 문자가 최대 편집거리가 되기 때문이다.)  
만약 그게 아니라면 수정하거나, 삽입하거나, 삭제한 편집 거리 중 최소값에 1만 더해주면된다.  
수정할 경우는 edit(i-1, j-1)+1이 되고, 삭제한 경우는 edit(i, j-1)+1, 삽입한 경우는 edit(i-1,j)+(0 or 1)이 된다.  
즉 edit(i,j) = min(edit(i-1,j-1)+(0 or 1), edit(i,j-1)+1, edit(i-1,j)+1)이 된다.  
> 0 or 1은 x[i]=y[j] 이면 0, 아니면 1이다.  

## 14.2 문자열 해싱
해시값은 문자열이ㅡ 구자를 이용하여 계산한 정수 값이다.  
두 문자열이 같다면 해시값이 같아지므로 문자열이 같은지 판단할 수 있다.  

### 14.2.1 다항식 해싱
다항식 해싱은 길이가 n인 문자열 s에 대해서 다음과 같이 계산한다.  
`(s[0]A^n-1+s[1]A^n-2....s[n-1]A^0) mod B`  
이때 s[n]은 문자의 아스키 코드 값이고 A와 B는 미리 정한 상수이다.  
다항식 해싱을 사용하면 문자열 s에 모든 부분 문자열의 해시값을 상수 시간에 계산할 수 있다.  
> 전처리 과정은 O(n)이 걸린다.  
아래의 공식을 통해서 O(1)시간에 s[a...b]에 대한 해시값을 만들 수 있다.
```
h[0] = s[0]
h[k] = (h[k-1]A+s[k]) mod B
p[0] = 1
p[k] = (p[k-1]A) mod B
s[a...b] = (h[b]-h[a-1]p[b-a+1]) mod B
```
이때 a는 0보다 커야하며 a=0일 경우에 해시값은 h[b]이다.  

### 14.2.2 응용
해싱을 이용하면 문자열에 대한 임의의 부분 문자열을 O(1) 시간에 비교할 수 있다.  

#### 패턴 매칭
문자열 s와 패턴 p가 있을 때 s내에서 p가 나타나는 위치를 찾는 문제이다.  
무차별 대입으로 O(n^2)시간에 풀 수 있지만 해싱을 통해서 O(n) 시간에 해결 할 수 있게 된다.  

#### 서로 다른 부분 문자열
어떤 문자열에 대해 길이가 k인 서로 다른 부분 문자열의 수를 세어보자.
해당 문자열에 대해서 해싱을 만드는데 O(n), 문자열의 길이 n에 대해서 부분 문자열을 찾는데 O(n)이 걸린다고 생각했는데 책에서는 O(n log n)이라고 한다. 
배열의 시작점 x를 n-k까지 가면서 만들어진 해싱에 대해서 중복체크를 하면서 해싱값을 저장하면 서로 다른 부분 문자열의 수를 찾을 수 있지 않을까 생각했다.  

#### 사전 순 첫 번째 회전
구지 이렇게 해야할까?  
그냥 회전 시킨 문자열에 대해서 일정 길이 k를 갖는 접두사에 대해서 아스키 코드로 변환하여 합을 하여 가장 최소 값을 가지는 문자열이 사전 순 첫 번째 문자열이 되지 않는가..?  
사실 내가 생각한 것이 오류일 수도 있는데 의견을 나눠봐야할 것 같다.  

### 14.2.3 충돌과 상수
해시값을 비교할 떄는 충돌이 생길 수도 있다.  
이는 다른 문자열이지만 해시값이 동일 한 경우를 뜻하는데 해시값을 만드는 상수 A,B를 적절하게 선정하면 충돌확률을 낮출 수 있다.  
> 그냥 언어에서 제공하는 해싱함수를 사용하는걸 추천한다. 결론적으로는 상수가 크면 클 수록 충돌을 낮출 수 있다는 점이다.  


## 14.3 Z-알고리즘
길이가 n인 문자열에 대해서 z 배열은 k=0~n-1에 대해 k부터 시작하는 부분 문자열이면서 s의 접두사이기도한 가장 긴 문자열의 길이를 저장하는 배열이다.  
z[k]=p라면 s[0...p-1]과 s[k...k+p-1]이 같고, s[p]와 s[k+p]가 다르다는 것이다.(? 뭔소리야)
> 이해하기 어렵다. 다시 읽어봐야겠다.

## 14.4 접미사 배열
문자열의 접미사 배열은 접미사의 사전순 순서를 나타내는 배열이다.  
문자열 s에 대해서 s[i...n-1]을 이루는 접미사 부분 배열을 사전순으로 나열한 것이다.  
예를 들어 i가 1이고 사전 순으로 s[i...n-1]이 7번 째라면 접미사 배열 sa[7] = 1이 된다.  

### 14.4.1 접두사를 두 배씩 늘려가는 방법
사실 이해하지 못했다. 내가 너무 멍청하다.  
> 결론적으로는 sort함수를 이용해서 소트하는 방법이 O(n log^2 n) 시간이라 이것도 충분하게 효율적이랜다.  

### 14.4.2 패턴 찾기
접미사 배열에서 패턴을 찾는 방법은 매우 쉽고 빠르다.  
O(k log n)시간에 수행할 수 있으며, 이분 탐색을 이용하여 패턴에 있는 문자를 찾으면 된다.  
첫 문자를 이분 탐색으로 찾아서 범위를 특정 짓고, 다음 문자를 해당 범위에서 또 이분 탐색으로 찾아 특정지으면 된다.  

### 14.4.3 LCP 배열
LCP 배열은 접미사 배열 중에서 최장 공통 접두사 길이를 저장하는 배열이다.  
BAABB와 BAB의 최장 공통 접두사는 BA로 길이는 2임을 알 수 있다.  
> 접미사 배열의 마지막 접미사에는 LCP값이 없다.(왜?)
LCP배열의 알고리즘을 살펴보자면 이전 LCP값 x보다 최소 x-1을 가질 수 있고, 이는 다음 접미사와 비교할 때 x-1번째부터 비교하기 시작하면 된다는 점이다  
이렇게 만든 LCP배열로 문자열에서 서로 다른 부분 문자열의 개수를 쉽게 계산할 수 있는데  
`(문자열의 길이*문자열의 길이+1)/2 - LCP배열의 합`으로 쉽게 계산 할 수 있다.  
