# Chapter9. 구간 질의
배열에 대한 구간 질의를 효율적으로 처리하는 자료구조를 살펴보자.  
예로는 구간 합 질의, 구간 최소 질의가 있다.  

## 9.1 정적 배열에 대한 질의
배열이 정적인 경우, 즉 질의 사이에 배열의 원소가 절대로 변하지 않는 경우를 살펴본다.  
이 경우에는 배열에 대한 전처리만 잘 수행해도 구간 질의에 효율적으로 답 할 수 있다.  
먼저, 누적 합 배열을 이용하여 구간 질의를 간단하게 처리하는 방법을 살펴본다.  

### 9.1.1 합 질의
구간 합 질의 `sum(a,b)`는 배열에서 위치가 구간 [a,b]에 속하는 원소들의 합을 나타낸다.  
만약 누적 합 배열을 미리 구해놓는다면 `PrefixSum[b]-PrefixSum[a-1]`로 쉽게 구간 합 질의를 해결 할 수 있다.  
누적합 배열의 각 원소는 주어진 배열에서 그 위치까지의 원소들의 합이다. 즉 위치 k의 원소는 `sum(0,k)`이다.  

누적 합 배열은 `O(n)`시간에 구할 수 있으며 `sum(a,b)`는 `O(1)`시간에 구할 수 있다.  

#### 고차원에 대한 일반화
책에 있는 그림을 표현하고 싶지만 마땅치 않아 그냥 글로 표현한다.  
임의의 직사각형 크기의 범위의 부분 합을 구하기 위해서는 다음 공식으로 나타낼 수 있다.  
`S(A)-S(B)-S(C)+S(D)`  
> 이 수식이 어떻게 유도된지는 잘 모르겠다.

### 9.1.2 최소 질의
구간 최소 질의 `min(a,b)`는 배열에서 위치가 구간 [a,b]에 속하는 원소들의 합을 나타낸다.  
이 책에서 소개하는 기법은 전처리를 `O(n log n)`시간에 해결하고 `O(1)`시간에 최소 질의를 해결하는 알고리즘이다. 
이 기법은 Bender와 Farach-colton이 만든 것으로 **희소 테이블** 이라는 이름으로 불린다.  

아이디어는 구간의 길이에 해당하는 `b-a+1`값이 2의 거듭제곱인 `min(a,b)`를 사전에 미리 전부 다 구해놓는 것이다.  
> 이해가 되지 않아서 .. 정리 후 다시..


## 9.2 트리형 자료구조

### 9.2.1 이진 인덱스 트리
이진 인덱스 트리 혹은 팬윅 트리는 누적합 배열의 동적인 자료구조라고 볼 수 있다.  
이 자료구조는 `O(log n)`시간이 걸리는 연산 두가지가 존재하는데, 첫 번째는 구간합 질의를 처리하는 연산. 두 번째는 배여의 원소를 갱싱하는 연산이다.  
이 자료구조는 트리라고 언급되지만 사실상 배열의 형태료 포시한다. 또한 모든 배열의 인덱스가 1부터 시작한다고 가정한다.  

`p(k)`를 2의 거듭 제곱인 k의 약수 중에서 그 크기가 제일 큰 것으로 생각하면 배열 `tree`에 다음과 같이 이진 인덱스 트리를 저장 할 수 있다.  
`tree[k] = sum(k-p(k)+1, k)`  
즉, tree[k]에 저장되는 값은 원래 배열에 대해 위치 k에 끝나면서 그 길이가 `p(k)`인 구간의 합이다.  
예를 들어서 `p(6)=2`이므로 `tree[6] = sum(5,6)`이다.  

이진 인덱스 트리를 이용하면 `sum(1,k)`에 대해 `O(log n)`에 구할 수 있는데 그 이유는 구간 [1,k]를 이진 인덱스 트리에 합이 저장된 부분 구간 `O(log n)`개로 나눌 수 있기 때문이다.  
`sum(1,7)`을 구하는 경우를 예를 들어보자.  
`sum(1,7) = sum(1,4) + sum(5,6) + sum(7,7)` 로 나눠서 구할 수 있다.  
만약 a가 1보다 크다면 이전에 누적 합 배열에서 사용한 공식을 토대로 개조하여 사용해도 된다.  
`sum(a,b) = sum(1,b) - sum(1,a-1)` 

만약 배열의 원소를 수정했다면 이를 갱신하기 위한 시간이 필요한데, 이 또한 `O(log n)`시간이 걸린다.

#### 구현

### 9.2.2 구간 트리
