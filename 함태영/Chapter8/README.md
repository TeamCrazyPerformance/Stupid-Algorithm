# Chapter8. 알고리즘 설계 기법
고-오급 알고리즘 설계 기법을 배워보자.  

## 8.1 비트 병렬 알고리즘
비트 병렬 알고리즘은 비트 연산을 통해서 효율적인 문제해결을 끌어 낼 수 있을 때 사용하는 기법이다.  
### 8.1.1 해밍거리
Hamming Distance는 문자열 a,b가 존재할 때 두 문자열이 일치하지 않는 위치의 개수이다.  

문자열이 이진 문자열이라는 가정하에 아래의 예를 살펴보자.  
예를 들어서 `hamming(00100, 11011)`은 5라는 결과를 내놓을 수 있다.  
이를 단순하게 알고리즘 구현을 해보면 아래와 같을 것이다.  
```cpp
int hamming(string a, string b){
    int d=0;
    for(int i=0; i<k; i++){
        if(a[i]!=b[i]) d++;
    }
    return d;
}
```

하지만 더욱 더 빠르게 수행하는 방법이 있는데, 문자열은 비트로 표현할 수 있음을 이용하면 매우 간단해진다.  
문자열 두개를 int형으로 저장한 뒤, xor 연산을 진행하면 결과로 서로 다른 위치에 1이 저장이 된다. 위의 경우라면 `11111`이 나올 것이다.  
그런 다음 비트의 개수를 구해주는 `__builtin_popcount`함수를 이용하면 된다.  
```cpp
int hamming(int a, int b){
    return __builtin_popcount(a^b);
}
```

첫 번째 코드보다 비트 병렬 알고리즘을 사용한 두 번째 코드가 약 20배 정도 빠름이 증명되어있다.  

### 8.1.2 부분 격자 세기
n*n 크기의 격자가 있는데 각 지점에 검은색(1)과 흰색(0)이 칠해져있다.  
네 귀퉁이가 칠해져있는 부분을 부분 격자라고 정의하자. 

이 문제를 해결하기 위해선 모든 행의 조합을 살펴보아야 하기때문에 기본적으로 `O(n^2)`의 시간복잡도를 가지고  
각각의 행마다 칠한 상태를 확인하기 위해서 `O(n)`의 시간 복잡도가 필요하므로 최종적으로 `O(n^3)`이 된다.  

위 코드를 구현해보았다.  
```cpp
int ans = 0;
for(int a=0; a<n; a++){
    for(int b=a; b<n; b++){
        int count=0;
        for(int i=0; i<n; i++){
            if(arr[a][i] == 1 && arr[b][i]==1) count++;
        }
        if(count!=1) ans += (count*(count-1))/2; 
    }
}
```
`(count*(count-1))/2` 해당 수식은 count 개수를 기준으로 몇 개의 격자가 있는지 세어주는 수식이다.  
즉 count가 3이라고 했을 때 모서리가 될 수 있는 경우의 수가 3개가 있다는 것이고, 부분적으로 세어보면 총 3개가 나온다.  

**만약 각 행을 비트로 나타내어 저장을 한다면?**  
```cpp
int ans = 0;
for(int a=0; a<n; a++){
    for(int b=a; b<n; b++){
        int count = (arr[a]&arr[b]).count();
        if(count!=1) ans += (count*(count-1))/2; 
    }
}
```

원래의 알고리즘보다 30배정도 빠름이 증명되어있다.  

### 8.1.3 그래프의 도달 가능성
노드가 n개로 구성된 DAG가 있을 경우 각 노드에 대한 돌 가능한 노드 개수를 찾아보자.  
만약 동적 계획법을 이용한다면 `O(n^2)` 시간복잡도에 해결이 가능할 것이다.
> 사실 그냥 각 노드별로 dfs, bfs + 적절한 알고리즘을 써도 된다.  또한 저 알고리즘 이해 안된다.  


## 8.2 분할 상환 분석
알고리즘의 구조적 형태를 보고 시간 복잡도를 알아내지 못하는 경우, 알고리즘 전체에 걸쳐 수행되는 연산의 총 수행 시간을 추정하는 분석법이다.  

### 8.2.1 두 포인터 기법
두 포인터 기법은 배열을 따라 포인터 2개를 이동시키는 방법이다. 
두 포인터는 모두 한쪽 방향으로 이동하며 알고리즘을 수행한다.  

예를 들어서 아래의 문제를 생각해보자.  
```
양의 정수 n개로 이루어진 배열이 존재한다.
목표 값 x를 만들 수 있는 부분 배열이 존재하는지 확인해보자.
```

포인터 2개를 두어서 오른쪽 포인터는 부분 배열의 합이 x를 초과하지 않으면 움직이고, 왼쪽 포인터는 오른쪽 포인터가 움직이지 못하면 움직인다.  
이에 대한 시간복잡도의 상한선은 오른쪽 포인터가 된다. 그 이유는 왼쪽 포인터의 이동횟수는 오른쪽 포인터의 이동 횟수에 종속되기 때문이다.  
따라서 알고리즘의 수행도가 `O(n)`이 된다.

#### 2SUM 문제
```
2SUM 문제
수 n개로 이루어진 배열과 목표 합 x가 존재할 때
합이 x가 되는 배열 원소 두 개를 구하거나, 없음을 나타내라
```
이 문제를 풀기 위해 배열을 정렬시킨다. 포인터 두 개는 배열의 양 끝 쪽에 배치하며 룰에 따라 이동한다.  
오른쪽 포인터는 2개의 포인터가 가르키는 값의 합이 목표값이 클 때 왼쪽으로 이동한다.  
왼쪽의 포인터는 2개의 포인터가 가르키는 값의 합이 목표값보다 작을 때 오른쪽으로 이동한다.  
최악의 경우에는 포인터가 만나는 지점까지 n번 이동하기에 `O(n)`의 시간복잡도를 가지며 정렬 시간 `O(n log n)`을 가진다.  
따라서 `O(n log n)` 시간내로 문제를 해결 할 수 있다.


### 8.2.2 보다 작으면서 가장 가까운 원소
> ?? 이해안감. 왜 넣어놨는지 이해불가

### 8.2.3 슬라이딩 윈도의 최솟값
슬라이딩 윈도란 고정된 크기의 부분배열을 의미한다.  
전체 배열에서 슬라이딩 윈도가 이동 할 때마다 최소값을 관리하려면 위의 보다 작으면서 가장 가까운 원소를 생각하면 된다.  

아래의 룰을 생각하면 알고리즘을 떠올리기 쉽다.  
첫 턴일 경우에는 덱에 슬라이딩 윈도에 포함되는 원소를 아래의 룰 대로 집어 넣는다.  
슬라이딩 윈도가 움직이면 덱에 슬라이딩 윈도에 새롭게 들어온 원소를 아래의 룰 대로 집어 넣는다.  
슬라이딩 윈도가 움직이면 덱에서 슬라이딩 윈도에 포함되지 않는 원소를 찾아 삭제한다.  
새로 추가하는 원소가 덱의 끝 원소보다 작은 경우, 덱의 끝 원소를 삭제하고 새롭게 원소를 추가한다.

이 과정을 통해 만들어진 덱의 첫 번째 원소가 최소 값이다.  

## 8.3 최솟값 구하기
> 작성중
