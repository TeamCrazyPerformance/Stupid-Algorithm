# Chapter8. 알고리즘 설계 기법
고-오급 알고리즘 설계 기법을 배워보자.  

## 8.1 비트 병렬 알고리즘
비트 병렬 알고리즘은 비트 연산을 통해서 효율적인 문제해결을 끌어 낼 수 있을 때 사용하는 기법이다.  
### 8.1.1 해밍거리
Hamming Distance는 문자열 a,b가 존재할 때 두 문자열이 일치하지 않는 위치의 개수이다.  

문자열이 이진 문자열이라는 가정하에 아래의 예를 살펴보자.  
예를 들어서 `hamming(00100, 11011)`은 5라는 결과를 내놓을 수 있다.  
이를 단순하게 알고리즘 구현을 해보면 아래와 같을 것이다.  
```cpp
int hamming(string a, string b){
    int d=0;
    for(int i=0; i<k; i++){
        if(a[i]!=b[i]) d++;
    }
    return d;
}
```

하지만 더욱 더 빠르게 수행하는 방법이 있는데, 문자열은 비트로 표현할 수 있음을 이용하면 매우 간단해진다.  
문자열 두개를 int형으로 저장한 뒤, xor 연산을 진행하면 결과로 서로 다른 위치에 1이 저장이 된다. 위의 경우라면 `11111`이 나올 것이다.  
그런 다음 비트의 개수를 구해주는 `__builtin_popcount`함수를 이용하면 된다.  
```cpp
int hamming(int a, int b){
    return __builtin_popcount(a^b);
}
```

첫 번째 코드보다 비트 병렬 알고리즘을 사용한 두 번째 코드가 약 20배 정도 빠름이 증명되어있다.  

### 8.1.2 부분 격자 세기
n*n 크기의 격자가 있는데 각 지점에 검은색(1)과 흰색(0)이 칠해져있다.  
네 귀퉁이가 칠해져있는 부분을 부분 격자라고 정의하자. 

이 문제를 해결하기 위해선 모든 행의 조합을 살펴보아야 하기때문에 기본적으로 `O(n^2)`의 시간복잡도를 가지고  
각각의 행마다 칠한 상태를 확인하기 위해서 `O(n)`의 시간 복잡도가 필요하므로 최종적으로 `O(n^3)`이 된다.  

위 코드를 구현해보았다.  
```cpp
int ans = 0;
for(int a=0; a<n; a++){
    for(int b=a; b<n; b++){
        int count=0;
        for(int i=0; i<n; i++){
            if(arr[a][i] == 1 && arr[b][i]==1) count++;
        }
        if(count!=1) ans += (count*(count-1))/2; 
    }
}
```
`(count*(count-1))/2` 해당 수식은 count 개수를 기준으로 몇 개의 격자가 있는지 세어주는 수식이다.  
즉 count가 3이라고 했을 때 모서리가 될 수 있는 경우의 수가 3개가 있다는 것이고, 부분적으로 세어보면 총 3개가 나온다.  

**만약 각 행을 비트로 나타내어 저장을 한다면?**  
```cpp
int ans = 0;
for(int a=0; a<n; a++){
    for(int b=a; b<n; b++){
        int count = (arr[a]&arr[b]).count();
        if(count!=1) ans += (count*(count-1))/2; 
    }
}
```

원래의 알고리즘보다 30배정도 빠름이 증명되어있다.  

### 8.1.3 그래프의 도달 가능성
노드가 n개로 구성된 DAG가 있을 경우 각 노드에 대한 돌 가능한 노드 개수를 찾아보자.  
만약 동적 계획법을 이용한다면 `O(n^2)` 시간복잡도에 해결이 가능할 것이다.
> 사실 그냥 각 노드별로 dfs, bfs + 적절한 알고리즘을 써도 된다.  또한 저 알고리즘 이해 안된다.  


## 8.2 분할 상환 분석
알고리즘의 구조적 형태를 보고 시간 복잡도를 알아내지 못하는 경우, 알고리즘 전체에 걸쳐 수행되는 연산의 총 수행 시간을 추정하는 분석법이다.  

### 8.2.1 두 포인터 기법
두 포인터 기법은 배열을 따라 포인터 2개를 이동시키는 방법이다. 
두 포인터는 모두 한쪽 방향으로 이동하며 알고리즘을 수행한다.  

예를 들어서 아래의 문제를 생각해보자.  
```
양의 정수 n개로 이루어진 배열이 존재한다.
목표 값 x를 만들 수 있는 부분 배열이 존재하는지 확인해보자.
```

포인터 2개를 두어서 오른쪽 포인터는 부분 배열의 합이 x를 초과하지 않으면 움직이고, 왼쪽 포인터는 오른쪽 포인터가 움직이지 못하면 움직인다.  
이에 대한 시간복잡도의 상한선은 오른쪽 포인터가 된다. 그 이유는 왼쪽 포인터의 이동횟수는 오른쪽 포인터의 이동 횟수에 종속되기 때문이다.  
따라서 알고리즘의 수행도가 `O(n)`이 된다.

#### 2SUM 문제
```
2SUM 문제
수 n개로 이루어진 배열과 목표 합 x가 존재할 때
합이 x가 되는 배열 원소 두 개를 구하거나, 없음을 나타내라
```
이 문제를 풀기 위해 배열을 정렬시킨다. 포인터 두 개는 배열의 양 끝 쪽에 배치하며 룰에 따라 이동한다.  
오른쪽 포인터는 2개의 포인터가 가르키는 값의 합이 목표값이 클 때 왼쪽으로 이동한다.  
왼쪽의 포인터는 2개의 포인터가 가르키는 값의 합이 목표값보다 작을 때 오른쪽으로 이동한다.  
최악의 경우에는 포인터가 만나는 지점까지 n번 이동하기에 `O(n)`의 시간복잡도를 가지며 정렬 시간 `O(n log n)`을 가진다.  
따라서 `O(n log n)` 시간내로 문제를 해결 할 수 있다.


### 8.2.2 보다 작으면서 가장 가까운 원소
> ?? 이해안감. 왜 넣어놨는지 이해불가

### 8.2.3 슬라이딩 윈도의 최솟값
슬라이딩 윈도란 고정된 크기의 부분배열을 의미한다.  
전체 배열에서 슬라이딩 윈도가 이동 할 때마다 최소값을 관리하려면 위의 보다 작으면서 가장 가까운 원소를 생각하면 된다.  

아래의 룰을 생각하면 알고리즘을 떠올리기 쉽다.  
첫 턴일 경우에는 덱에 슬라이딩 윈도에 포함되는 원소를 아래의 룰 대로 집어 넣는다.  
슬라이딩 윈도가 움직이면 덱에 슬라이딩 윈도에 새롭게 들어온 원소를 아래의 룰 대로 집어 넣는다.  
슬라이딩 윈도가 움직이면 덱에서 슬라이딩 윈도에 포함되지 않는 원소를 찾아 삭제한다.  
새로 추가하는 원소가 덱의 끝 원소보다 작은 경우, 덱의 끝 원소를 삭제하고 새롭게 원소를 추가한다.

이 과정을 통해 만들어진 덱의 첫 번째 원소가 최소 값이다.  

## 8.3 최솟값 구하기
만약 어떤 함수`f(x)`가 감소하다가 최소값에 도달한 후에 상승을 지속한다고 생각해보자.  
그렇다면 이 함수를 이용해 최소값을 구하는 방법은 매우 쉬울 것이다.  

### 8.3.1 삼진탐색
삼진탐색을 이용하면 감소하다가 증가하는 함수의 최솟값을 쉽게 구할 수 있을 것이다.  
함수 `f(x)`를 최소화 시키는 x가 구간[x1, x2]에 있음을 알고있다고 가정하고 이 구간을 세 조각으로 나눈다.  
[x1, a], [a, b], [b, x2]로 구간을 나누되 a와 b는 아래의 공식으로 정의한다.  
`a = (2x1+x2)/3, b = (x1+2x2)/3`  
만약 `f(a)>f(b)`라면 다음 스캔 구간은 [a,x2]가 된다.  
이를 반복하면서 구간[a,x2]사이의 원소가 한 개가 될때 까지 반복하면 된다.  

### 8.3.2 볼록 함수
어떤 함수의 그래프를 그렸을 때, 그래프의 두 점을 잇는 선분이 함수의 그래프보다 항상 위쪽이거나 겹친다면 그 그래프를 볼록하다고 한다.  
만일 볼록 함수를 최소화는 x가 구간 [x1, x2]안에 존재하는 것을 알고 있다면 삼진 탐색을 이용하여 최솟값을 구할 수있다.  
하지만 볼록 함수의 최소 값은 여러 개가 존재할 수 있음을 유의 해야한다.  
> f(x)=0이라면 모든 x에 대해서 최소값 0을 가진다.

### 8.3.3 합 최소화
n개의 수가 존재할 때, 아래의 공식을 토대로 합을 최소화는 x를 구하는 문제를 생각해보자.  
`|a1-x|+|a2-x|...+|an-x|`
이 때 각각의 함수 `|ak-x|`는 `ak`가 정렬되어있다는 가정을 한다면 볼록 함수이기 때문에 위의 공식도 볼록 함수가 된다.  
이를 이용한 삼진 탐색을 진행하면 되지만, 위의 공식은 중앙값이 합을 최소화 하는 x가 된다.  

어찌되었든 합 최소화 문제는 n개의 수를 정렬 시킨 후, 삼진 탐색을 진행하면 해답을 찾을 수 있다는 점이다.  
뒤에 나오는 문제도 요점과 조금 어긋난 듯하여 생략하였다.  


