# Chapter7. 그래프 알고리즘

## 7.1 그래프 기본
그래프를 나타내기 위해서 사용하는 자료구조를 살펴보자.  

### 7.1.1 그래프 용어
그래프는 노드(node 혹은 vertex)와 그들 사이를 잇는 간선(edge)으로 구성되어있다.  

**경로(Path)** 는 임의의 노드 N1에서 N2로 갈 수있는 길을 의미한다.  
경로의 길이는 해당 경로에서 지나치는 간선들의 개수로 나타낼 수 있으며 만약 간선에 가중치가 존재한다면 가중치를 길이라 생각하면 된다.  

**연결 그래프(Connected Graph)** 는  그래프에 존재하는 노드들 중에 도달할 수 없는 노드가 없다면 연결 그래프라고 부른다.  
**컴포넌트(Component)** 는 비 연결 그래프에서 사이클을 구성하는 집합을 의미한다.  
**트리(Tree)** 는 그래프에서 사이클이 없는 연결 그래프를 의미한다.  
**방향 그래프(Directed Graph)** 는 노드간 이동 방향이 존재하는 그래프이다.
> 비 방향 그래프는 간선으로 연결만 되있다면 오고갈 수 있다.  
> 방향 그래프는 간선 하나가 어떤 노드로 갈 수 있는지 정의하고 있다.  

**가중 그래프(Weighted Graph)** 는 간선에 가중치가 존재하는 그래프이다.  
**이웃 또는 인접노드** 는 두 노드 사이를 이어주는 간선이 존재할 경우, 서로를 이웃 또는 인접노드라고 부른다.  
**차수** 는 임의의 노드 N의 인접노드의 갯수이다.  
**정규 그래프(Regular Graph)** 는 그래프에 존재하는 노드들의 차수가 모두 같은 경우 정규 그래프라고 부른다.  
**완전 그래프(Complete Graph)** 는 그래프에 존재하는 노드들이 해당 노드를 제외한 모든 노드들과 연결되어 있다면 완전 그래프라고 부른다.  
**정규 그래프(Regular Graph)** 는 그래프에 존재하는 노드들의 차수가 모두 같은 경우 정규 그래프라고 부른다.   
**이분 그래프(Bipartite Graph)** 는 이웃 노드 간 같은 색으로 칠할 수 없고 2가지 색상으로 모든 노드를 칠할 수 있다면 이분 그래프라고 부른다.  


### 7.1.2 그래프의 표현

#### **인접 리스트**
인접 리스트 표현법은 각 노드 x에 대해 간선으로 연결된 노드를 관리하는 방법이다.  
가장 대중적이며 효율성도 꽤 좋다.  

그래프를 그리기 힘들어서 말로 설명하자면  
노드가 5개가 존재한다고 가정하에 각 노드는 인접 노드를 관리하는 자료구조를 가지게된다.  
```cpp
vector<int> adj[5];
adj[0].push(1); // Node0은 1과 연결되어있다.
adj[0].push(4); // Node0은 4와 연결되어있다.
.
.
.
```

추가적으로 간선에 가중치를 줄 수 있는데 `{n,w}` 형태로 저장을 해주면된다.
```cpp
vector<pair<int,int>> adj[5];
adj[0].push({1,3}); // Node0은 1과 3의 가중치를 가지고 연결되어있다.
adj[0].push({4,1}); // Node0은 4와 1의 가중치를 가지고 연결되어있다.
.
.
.
```

#### **인접 행렬**
인접 행렬은 그래프에 포함된 간선을 나타내는 2차원 형태의 행렬이다.  
`int adj[N][N]`으로 선언하여 관리하는데, `int adj[x][y]`라면 x에서 y로 이동할 수 있는지를 나타낸다.
직관적으로 표현이 가능하지만 원소의 개수가 너무 많고, 노드의 개수가 많아지면 효율성이 떨어진다.  

#### **간선 리스트**
간선 리스트는 그래프에 존재하는 간선들을 특정한 순서에 따라서 저장한 리스트이다.  
형태는 `{n1, n2}`이며 n1에서 n2로 가는 간선이 있다는 것을 의미한다.  
```cpp
vector<pair<int, int>> edges; // 간선 리스트
edges.push_back({1,2}); // 1에서 2로 가는 간선이 존재한다.
edges.push_back({3,2}); // 3에서 2로 가는 간선이 존재한다.
edges.push_back({2,4}); // 2에서 4로 가는 간선이 존재한다.
vector<pair<int, int, int>> edges; // 가중치가 있는 간선 리스트
edges.push_back({1,2,5}); // 1에서 2로 가는 간선이 존재한다. 가중치는 5
edges.push_back({3,2,2}); // 3에서 2로 가는 간선이 존재한다. 가중치는 2
edges.push_back({2,4,9}); // 2에서 4로 가는 간선이 존재한다. 가중치는 9
```

## 7.2 그래프 순회
그래프 순회의 방법은 기본적인 2개의 알고리즘이 존재한다.  
### 7.2.1 깊이 우선 탐색(Depth-First Search, DFS)  
시작노드에서 연결된 간선을 따라서 이동하면서 갈 수 있는 여러 노드들 중 하나를 선택한다.
룰은 아래와 같다.
```
1. 시작 노드를 설정한다.
2. 시작 노드에서 갈 수 있는 노드를 확인한다.
3. 갈 수 있는 노드가 여러 개라면 하나만 택하여 2번 룰을 따른다.
4. 탐색한 노드가 이미 방문한 노드라면 갈 수 있는 다른 노드를 탐색한다.
```
위 룰을 기반으로 탐색을 진행하며 그래프 상에서 **깊게 들어가는 것** 을 확인 할 수 있다.  
그래서 Depth-First라고 한다.  
> 코드는,, 나중에

### 7.2.2 너비 우선 탐색(Breadth-First Search, BFS)  
시작노드에서 연결된 간선을 따라서 이동하면서 갈 수 있는 여러 노드들을 먼저 탐색한다.
룰은 아래와 같다.
```
1. 시작 노드를 설정한다.
2. 시작 노드에서 갈 수 있는 노드를 찾는다.
3. 갈 수 있는 노드가 여러 개라면 방문 Queue에 쌓아놓는다.
4. Queue에서 하나 씩 pop하여 방문하고 해당 노드에서 갈 수 있는 노드들은 3번 룰을 따른다.
```
위 룰을 기반으로 탐색을 진행하며 그래프 상에서 **넓게 탐색하는 것** 을 확인 할 수 있다.  
그래서 Breadth-First라고 한다.  
> 코드는,, 나중에

### 7.2.3 응용
#### 연결성 확인
주어진 그래프에서 탐색을 진행하였을 때, 모든 노드를 방문 할 수 없으면 연결 그래프라고 한다.  
만약 DFS를 이용해서 모든 노드를 확인할 수 없다면 이 그래프는 연결 그래프가 아님을 확인할 수 있다.  

#### 사이클 찾기
그래프 탐색과정에서 이미 방문한 노드(이웃노드)를 찾는다면 이는 사이클이 있음을 확인할 수 있다.  
혹은 간선의 개수로 체크하는 방법도 있다. 노드가 c개인데 간선의 개수가 c개 이상이라면 사이클이 있음을 확인할 수 있다.  

### 이분성 확인
단순히 탐색을 진행하면서 해당 노드에 색을 칠하면 간단하게 확인이 가능하다.  
만약 다음 탐색범위에 있는 노드가 이전 노드와 같은 색이라면 이분 그래프를 구성할 수 없는 것을 할 수 있을 것이다.  


## 7.3 최단 경로
