# Chapter4. 정렬과 탐색
---
## 4.1 정렬 알고리즘
### 4.1.1 버블 정렬
기본적인 정렬 중 하나이다.
시간 복잡도는 *`O(n^2)`* 이며 n번의 라운드마다 모든 원소들을 비교하여 swap한다.
아래는 버블정렬을 도식화 한 것이다.

![Bubble Sort](https://upload.wikimedia.org/wikipedia/commons/2/2a/Bubble_sort_with_flag.gif)

각 라운드마다 오른쪽 원소와 비교하여 swap을 진행하는데, 코드는 아래와 같다.
```cpp
for(int i=0; i<n; i++){
	for(int j=0; j<n-1; j++){
		if(arr[j]>arr[j+1]) swap(arr[j], arr[j+1]);
	}
}
```

> 역위란 원소의 순서가 잘못되었음을 의미한다.
> 이 역위를 이용하여 배열 정렬에 필요한 연산량을 알 수 있는데, 역위가 0이라면 정렬이 끝난 상태, 혹은 정렬을 하지 않아도 되는 상태이며 배열의 원소가 역순인 경우( 최악의 경우 )에는 n(n-1)/2개의 역위가 존재하므로 `O(n^2)`의 시간이 필요하게 된다.
> swap을 사용하는 버블 정렬은 각 라운드마다 1개의 역위가 줄어들기 때문에 최소한 `O(n^2)`의 시간이 필요하게 된다.

### 4.1.2 병합 정렬
효율적인 정렬 알고리즘은 보통 시간복잡도를 `O(n log n)`으로 가지고 있다.
대표적인 정렬 알고리즘으로 병합정렬(merge sort)가 있는데 아래의 룰을 토대로 진행한다.
1. 배열의 처음 원소를 a, 맨 끝 원소를 b라 정하고, a=b일 경우 진행을 하지 않는다. 부분배열이 원소 1개이기 때문에 정렬할 필요가 없기 때문이다.
2. 가운데 원소의 위치 k를 부분배열의 길이/2로 계산한다.
3. 재귀적으로 배열 a~k를 정렬시킨다.
4. 재귀적으로 배열 k+1~b를 정렬시킨다.
5. 정렬된 부분배열을 병합하여 정렬된 부분배열 a~b로 만든다.

이 알고리즘이 왜 `O(n log n)`인지 생각해보자.
배열을 절반씩 잘라나가기에 재귀 호출은 `O(log n)`의 시간이 걸릴 것이다.
재귀적으로 내려가면 부분배열의 원소가 2개가 되는 부분이 있을 것이다. 이를 통해 정렬하는 과정은 상수 시간으로 해결 할 수 있을 것이고, 배열을 병합하는 과정에서는 이미 정렬이 되어있기에 `O(n)`시간만큼 걸릴 것이다.
이를 정리하면 `O(n log n)` 시간복잡도를 가지게 된다.

```cpp
void mergeSort(int[] arr, int p, int q){
	if(p<q){
		int k = (p+q)/2;
		mergeSort(arr, p, k);
		mergeSort(arr, k+1, q);
		merge(arr, p, k, k+1, q);
	}
	else return;
}
void merge(int[] arr, int p, int p1, int q. int q1){
	int s1 = p;
	int s2 = q;
	int tmpidx = p;
	int[] tmp = new int[arr.length];
	while(s1<=p1 && s2<=q1){
    	if(arr[s1]<=arr[s2]) tmp[tmpidx++] = arr[s1++];
    	else tmp[tmpidx++] = arr[s2++];
	}
	while(s1<=p1) tmp[tmpidx++] = arr[s1++];
	while(s2<=q1) tmp[tmpidx++] = arr[s2++];
	for(int i=p; i<=q1; i++) arr[i] = tmp[i];
}
```


### 4.1.3 정렬의 하한
배열을 `O(n log n)`보다 빨리 정렬하는 것이 가능할까.
*원소 비교*에 기반을 둔 정렬이라면 이보다 빠를 수가 없다.
`x>y?`를 기반으로한 의사결정트리를 만들어본다면 결과적으로 `O(n log n)`을 벗어날 수 없다.

### 4.1.4 계수정렬
원소 비교가 아니라면 `O(n log n)`이란 하한선이 적용되지 않는데, 대표적으로 계수정렬이 있다.
이는 원소가 *0~c* 범위의 정수이면서 `c = O(n)`이 될만큼의 적당한 값일 때 효과 적이다.
배열에 일종의 매핑을 하는 것인데 아래의 표와 같은 원소가 존재한다고 생각해보자
`[1,3,3,2,2,4]`
해당 원소를 Index로 생각하고 배열을 재생성한다면
`[0,1,2,2,0,1]`
으로 변할 것이다.

이를 통해서 `O(n)`의 시간복잡도를 가진 정렬을 할 수 있지만 제약조건이 있다.
*상수 c는 작아야한다.* 라는 조건을 벗어난다면 `O(n)` 시간복잡도가 될 수 없다.
> 추가적으로 배열의 사이즈도 c만큼을 가져야하기 때문에 메모리 문제도 생신다.

### 4.1.5 실제 상황에서의 정렬
> 비교함수는 유용해보인다. 추후 정리 예정

---

## 4.2 정렬을 이용한 문제 풀이
정렬을 해야 풀 수 있는 문제들이 몇 존재한다.
대부분 `O(n log n)` 혹은 `O(n)` 시간 복잡도 내로 정렬을 하는 것을 원하고 있기 때문에 앞에서 소개한 *병합 정렬* 혹은 *c++ sort()*를 유용하게 사용할 수 있을 것이다.
### 4.2.1 스윕 라인 알고리즘
 정확하게 *Sweep line 알고리즘*이 무슨 뜻인지 모르겠다.
책에서는 *정렬된 수선대로 처리되는 이벤트의 집합으로 문제를 푸는 기법* 이라고 설명되어있는데, 와닿지 않는다.
그냥 정렬한 기준으로 Data set을 한 바퀴 돌면서 조건에 맞는 것을 찾는 것 같은데, 책에서는 다음 문제를 예로 설명하고 있다.
```
식당에 손님이 n명이 왔다갔다.
각 손님은 입장, 퇴장 시간이 다르며 머무르는 시간도 각각 다르다.
특정 시간대에 가장 많은 손님이 존재할 것인데, 손님이 가장 많을 때 인원을 체크하자.
```

해결 방법은 아래와 같다.
1. 손님들의 입장시간을 기준으로 sort를 진행한다.
2. 최초 입장시간부터 마지막 퇴장시간까지 스캔을 진행한다.
	1. 손님이 입장했으면 count를 1 증가 시킨다.
	2. 손님이 퇴장했으면 count를 1 감소 시킨다.
3. 	max 값을 update한 뒤, 2번으로 돌아간다.


### 4.2.2 이벤트 스케줄링
이벤트 스케줄링 문제는 아래와 같다.
```
n개의 스케줄이 존재한다.
시작과 종료시간이 존재하며 점유 시간은 각각 다르다.
1개의 스케줄을 진행하면 해당 시간에 다른 스케줄은 진행할 수 없다.
이 경우, 제한된 시간내에 가장 많은 스케줄을 실행할 수 있는 경우를 구하라.
```
 
데이터를 정렬하여 Greedy 알고리즘으로 해를 구할 수 있다.
> Greedy(탐욕) 알고리즘은 현재 상황에서 가장 좋은 것을 고르는 알고리즘이다.

정렬하는 방법은 아래와 같다.
1. 길이가 짧은 이벤트 순서대로
2. 시작시간이 빠른 이벤트 순서대로
3. 종료시간이 빠른 이벤트 순서대로

1,2 번은 조금만 생각해도 반례가 존재한다.
3번의 경우에는 시작시간만 체크한다면 반례가 존재하지 않는다.


### 4.2.3 작업과 데드라인
```
작업 n개의 소요시간과 데드라인이 주어진다.
작업의 데드라인이 d, 작업의 수행완료 했을 때 시간 x라면
d-x의 점수를 얻는다.
얻을 수 있는 최대의 점수는 얼마인가.
```
이 문제 또한 Greedy 알고리즘에 가깝다.
이벤트 스케줄링처럼 최대한 많은 스케줄을 진행하는 것이 아니라 점수를 최대한 많이 얻어야하는 문제이다.
작업의 데드라인보다 작업 수행 완료 시간이 더욱 더 점수에  많은 영향을 끼친다.
따라서 작업 수행 완료시간이 짧은 순으로 정렬하여 스케줄 하여야한다.

## 4.3 이진탐색
이진 탐색은 정렬 된 배열을 가지고 특정 원소가 존재하는지 찾는 알고리즘이다.
이진탐색, 이름과 걸맞게 시간복잡도는 `O(log n)`이다.

### 4.3.1 이진 탐색 구현
#### 첫 번째 방법
가장 전통적인 방법으로 아래의 룰을 따른다.
1. 배열의 길이 / 2의 위치에 있는 원소 값을 타겟 값 x와 비교한다.
	1. 원소 값이 타겟 값보다 크면 end위치를 해당 원소 위치-1로 설정
	2. 원소 값이 타겟 값보다 작으면 start위치를 해당 원소 위치+1로 설정
	3. 1번 반복
```cpp
int a=0, b=n-1;
while(true){
	int k = (a+b)/2;
	if(arr[k]==x) break;
	if(k==a) break;
	if(arr[k]>x) b = k-1;
	else a = k+1;
}
```

#### 두 번쨰 방법
> 이해안됨. 처음에 절반을 건너 뛰는데, 스킵한 값이 거기에 있으면?

### 4.3.2 최적해 구하기
> 작성중
