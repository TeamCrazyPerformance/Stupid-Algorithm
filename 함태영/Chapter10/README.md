# Chapter10. 트리 알고리즘
트리의 특별한 성질을 이용한 알고리즘을 배워보자.

## 10.1 기본 기술
트리는 n개의 노드와 n-1개의 간선으로 이루어진 사이클 없는 연결 그래프이다.  
트리에서 하나의 노드를 없애면 2개의 컴포넌트로 나뉘며, 하나의 노드를 넣으면 사이클이 생겨버린다.  
Leaf는 이웃이 하나만 있는 노드를 말한다.  
### 10.1.1 트리 순회
트리를 순회하는 방법은 일반적인 그래프 순회보다 구현이 쉽다.  
트리를 순회하는 전형적인 방법은 DFS를 이용하는 것이다.  
```cpp
void dfs(int s, int e){ // 현재노드 : s, 이전노드 : e
    for(auto u : adj[s]){
        if(u!=e) dfs(u,s);
    }
}
dfs(x,0); // 노드 x부터 탐색 시작. 0은 이전 노드가 없기 때문에 0으로 
```
#### 동적 계획법
트리를 순회하면서 어떤 계산을 하고 싶다면 동적 계획법을 사용할 수 있다.  
예를 들어 각 노드 s에 대해서 서브 트리의 노드 수를 계산하는 방법을 구현해보자..  
```cpp
void dfs(int s, int e){
    count[s] = 1;
    for(auto u : adj[s]){
        if(u==e) continue; // 이전 노드와 탐색 노드가 같다면 무시한다.
        dfs(u,s); // 탐색 시작
        count[s] += count[u]; // count[s]에 count[u]를 추가해줌. 재귀적으로 계산하면 count[u]는 자식 노드 개수가 됨.
    }
}
```

#### 이진 트리 순회
이진 트리엔 노드마다 왼,오른쪽 서브 트리가 있으며 이때 서브 트리가 빈 트리 일 수도 있다.  
순회 방법은 전위(루트노드->왼쪽->오른쪽), 중위(왼쪽->루트노드->오른쪽), 후위(왼쪽->오른쪽->루트노드)순회가 존재한다.  
트리의 전위 순회와 중위 순회만 알고 있다면 트리의 정확한 구조를 파악할 수 있다.  


### 10.1.2 지름 계산
트리의 지름이란 두 노드 간 경로의 길이 중 최대 값을 의미한다.  
지름을 `O(n)`시간에 확인 할 수 있는 알고리즘 두가지를 확인 할 것이다.  

#### 첫 번째 알고리즘(동적 계획법)
임의의 노드를 루트로 지정한 다음, 각 서브 트리에 대해서 문제를 푸는 바잇ㄱ이다.  
루트 트리에서 가장 긴 지름을 가진 경로에 루트 노드가 있다는 점을 가지고 접근을 해야한다.  
- toLeaf(x) : x에서 x의 서브트르에 속한 리프로 가는 경로의 최대 길이
- maxLength(x) : 가장 높은 지점이 x인 경로의 최대 길이


먼저 toLeaf(x)를 계산하기 위해서 x의 모든 자식 노드를 살펴보고, toLeaf(c)가 최대인 자식 노드 c를 찾은 뒤, 그 값에 1을 더한다.  
다음으로 maxLength(x)를 구하기 위해서 toLeaf(a) + toLeaf(b)가 최대가 되는 서로 다른 두 자식 노드 a,b를 찾은 뒤 그 값에 2를 더한다.  

#### 두 번째 알고리즘(DFS)
깊이 우선 탐색을 두 번 진행하는 방법이 있다.  
임의의 노드 a를 선택 한 뒤, 가장 먼 노드 b를 찾는다(DFS에서 가장 끝에 탐색되는 노드)
그리고 b노드에서 가장 먼 노드 c를 찾는다.  
> 너무 간단하지 않은가? 맘에 들어..

### 10.1.3 모든 최장 경로
트리의 모든 노드 x에 대해서 x에서 시작하는 경로의 최대길이 maxLength(x)를 구하는 문제이다.  
지름 구하는 문제의 일반화라 생각하면 된다.  
이 문제 역시 `O(n)` 시간만에 풀 수 있는데, 트리의 루트를 임의로 지정하는 것으로 시작한다.  
앞에서 설명한 지름 계산하는 알고리즘을 사용하는 것으로 해결이 가능하다.  

두 번째 문제는 모든 노드 x에 대해서 부모노드 p방향으로 올라가는 경로의 최대길이를 구하는 것이다.
> 뭔 개소리야..

## 10.2 트리 질의
트리에 대한 질의를 처리하는 방법에 대해서 알아보자.  

### 10.2.1 조상 찾기
루트 트리에서 노드 x의 k번째 조상은 x에서 시작하여 k번ㅈ 위로 올라간 노드이다.  
직접 k번 올라가면 되지만 다른 방법이 존재한다.  

전처리를 적당하게 한다면 ancestor(x,k)는 `O(log k)`만큼 시간안에 해결이 가능하다.  
ancestor(x,k)의 값을 k가 2의 거듭제곱인 경우 대해 계산을 하는 것이다.  
전처리 과정은 `O(n log n)` 시간이 걸리고 ancestor(x,k)는 `O(log k)`만에 해결 할 수 있다.  
> 사실 k가 그리 크지 않으면 그냥 찾는게 빠를 수도 있다. n이 k보다 크면 의미가 없다.  
> 또한 이진 트리의 경우에는 배열에 저장하여 이진 트리 성질을 통해서 접근하는게 10000배는 빠르다.  

### 10.2.2 서브트리와 경로
트리 순회 배열 : 루트 트리의 노드를 루트 노드에서부터 깊이 우선 탐색으로 방문한 순서대로 저장한 배열  
서브 트리는 트리 순회 배열에서 부분 배열을 이루고 있으며, 부분 배열의 첫 번째 원소가 서브 트리의 루트 노드가 된다.  

#### 서브트리 질의
트리의 각 노드에 값이 할당 되어 있다고 가정을 하고, 갱신 질의와 합 질의를 생각해보자.  

> 작성중