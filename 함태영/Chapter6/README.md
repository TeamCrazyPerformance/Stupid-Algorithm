# Chapter6. 동적 계획법(Dynamic programming)

문제의 최적해를 구하거나 답의 개수를 세는 과정에서 응용이 가능하다.  
간단 탐욕알고리즘은 항상 최적의 해를 내놓지 않다는 단점을 보여주면서  
동적 계획법에 대한 공부를 시작해보자.  

## 6.1 기본 개념
동적 계획법의 기본 요소를 알아본다.  
### 6.1.1 탐욕법이 실패하는 경우
앞서 소개한 **간단한 탐욕알고리즘은 항상 최적의 해를 내놓지 않는다** 를 확인해보자.  
```
코인 { 1,3,4,5 } 가 있다.
코인들을 사용하여 12를 만들 때, 최소로 사용한 코인의 갯수를 알아보자.
```
만약 탐욕 알고리즘으로 접근한다면 아래와 같을 것이다.  
**{5, 5, 1, 1}을 사용해서 총 4일거야!** 라고 답을 도출하겠지만  
사실은 **{4, 4, 4}를 사용해서 총 3입니다!** 가 답입니다.  

모든 방식을 다 찾아보는 Brute Force 알고리즘을 쓴다고 하면 답은 찾을 수 있겠지만  
입력의 크기가 매우 커진다면 속도는 기하급수적으로 느려질 것이 뻔하다.  

이런 단점을 보완하기 위해서 **동적 계획법**이 필요한 것이다!

### 6.1.2 최적해 구하기
동적 계획법을 사용하기 위해서는 **재귀적으로 접근하는 방법**을 고민해봐야한다.  
위와 같은 케이스에서는 1을 만드는 경우부터 n을 만드는 경우를 생각해봐야하는데,  
각 단계마다 최적의 해를 구하기 위해서는 이전의 단계 값을 참고하는 것이 필수적이다.  

```
solve(x) = INF (x<0)
solve(x) = 0 (x=0)
solve(x) = min(solve(x-c)+1) (x>0)
```
위의 점화식을 설명하자면, x가 0보다 작은 경우는 존재할 수가 없기 때문에 INF 값으로 두었다.  
x=0인 경우에는 모든 코인을 사용해도 만들 수가 없으므로 답은 0이다.
그 외 케이스인 경우에는 현재 x값에서 모든 코인을 빼고 + 1을 한 최소 값이 답이 된다.

```cpp
int solve(int x){
    if(x<0) return 99999999;
    if(x==0) return 0;
    if best = 99999999;
    for(auto a : coins){
        best = min(best, solve(x-a));
    }
    return best;
}
```
위와 같이 구현한 함수는 solve를 계속 타고 들어가기 때문에 속도적인 측면에서 비효율적이다.
이를 개선하기 위해서는 **메모이제이션** 기법을 사용하면 된다.

#### **메모이제이션**
위의 함수 값을 흘려보내지 않고 배열에 저장하여 재사용하는 기법이다.  
`bool ready[N]`은 solve(x)가 계산되었는지 체크하고  
`int value[N]`은 solve(x)가 계산된 값을 넣는 변수로 지정한다.
그러면 코드는 아래와 같이 변한다.  
```cpp
int solve(int x){
    if(x<0) return 99999999;
    if(x==0) return 0;
    if(ready[x]) return value[x];
    if best = 99999999;
    for(auto a : coins){
        best = min(best, solve(x-a));
    }
    ready[x] = true;
    value[x] = best;
    return best;
}
```
저장된 값을 가지고 return을 해주기 때문에 복잡도가 상당하게 줄어드는 것을 확인할 수 있다.

#### **반복문을 이용한 구현**
위의 코드를 반복문으로만 구현할 수 있다.
```cpp
value[0]=0;
for(int x=1; x<=n; x++){
    value[x]=9999999;
    for(auto c : coins){
        if(x-c>=0)
            value[x] = min(value[x-c]+1, value[x]);
    }
}
```
위의 코드가 더 간결하고 속도 또한 빠르다.  
하지만 동적계획법을 구상하기에는 재귀함수로 표현하는 것이 더 쉽다.

#### **해답 구성하기**
위의 답에 대한 코인의 구성 내용을 아래와 같은 로직으로 찾을 수 있다.
```cpp
vector<int> v;
for(int x=1; x<=n; x++){
    value[x]=9999999;
    for(auto c : coins){
        if(x-c>=0 && value[x-c]+1<value[x]){
            value[x] = value[x-c]+1;
            v.push_back(c);
        }
    }
}
for(auto c : v){
    cout << c << endl;
}
```

#### **해의 개수 세기**
동전 문제를 변형하여 합 x를 만드는 경우의 수를 세는 문제도 있다.  
재귀적인 방법으로 해결할 수 있는데 아래의 로직과 같다.  
1. 합 x를 만드는 경우의 수를 `solve(x)`라고 나타내자.  
2. 점화식은 아래와 같다.
```
coin = {1,3,5} 일 떄
solve(x) = solve(x-1) +
            solve(x-3) +
            solve(x-5)
```
그리고 이를 일반화하면 아래와 같다.  
```
solve(x) = 0 (x<0)  
solve(x) = 1 (x=0)
solve(x) = sum(solve(x-c)) (x>0, c=coin)
```
이를 토대로 x에 대한 해답을 찾을 수 있게 된다.  
코드는 아래와 같다.
```cpp
count[0] = 1;
for(int x=1; x<=n; x++){
    for(auto c : coins){
        if(x-c>=0) count[x] += count[x-c];
    }
}
```

## 6.2 다른 예제
앞서 소개한 내용은 동적계획법의 기본과 그 예제였다.
이제 동적계획법을 이용해서 효율적으로 문제를 푸는 것을 보자.

### 6.2.1 최장 증가 부분 수열
원소가 n개인 배열의 일부 원소를 골라 만든 부분 수열 중  
각 원소가 이전 원소보다 크다는 조건을 만족하면서 그 길이가 최대인 것을 **최장 증가 부분 수열** 이라고 한다. 
`[6,2,5,1,7,4,8,3]`이라는 배열이 존재할 때 위의 조건을 만족하는 부분배열은  
`[2,5,7,8]`이다.
어떻게 동적 계획법을 사용할까?  
먼저 `lenght(k)`를 최장 증가 부분 수열의 길이라고 생각하자.  
그렇다면 이 `length(k)`를 계산하기 위해서는 어떤 로직이 필요할까.
조건 1. 이전 원소보다 커야한다.  
조건 2. 길이가 최대여야한다.  
라는 힌트를 이용해보면  
`array[k]>array[i]`이면서 `length[k]`가 최대로 되어야 한다.  

그렇다면 `length[k]=max(length[k], length[i]+1)`이라는 공식이 생긴다.  
이를 토대로 코드를 작성하면 아래와 같다.  
```cpp
for(int k=0; k<n; k++){
    for(int i=0; i<k; i++){
        if(arr[i]<arr[k]) 
            length[k] = max(length[k], length[i]+1);
    }
}
```
이 알고리즘은 `O(n^2)`의 시간복잡도를 가진다.

### 6.2.2 격자상의 경로

> 작성중.