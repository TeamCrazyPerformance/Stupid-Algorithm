# Chapter6. 동적 계획법(Dynamic programming)

문제의 최적해를 구하거나 답의 개수를 세는 과정에서 응용이 가능하다.  
간단 탐욕알고리즘은 항상 최적의 해를 내놓지 않다는 단점을 보여주면서  
동적 계획법에 대한 공부를 시작해보자.  

## 6.1 기본 개념
동적 계획법의 기본 요소를 알아본다.  
### 6.1.1 탐욕법이 실패하는 경우
앞서 소개한 **간단한 탐욕알고리즘은 항상 최적의 해를 내놓지 않는다** 를 확인해보자.  
```
코인 { 1,3,4,5 } 가 있다.
코인들을 사용하여 12를 만들 때, 최소로 사용한 코인의 갯수를 알아보자.
```
만약 탐욕 알고리즘으로 접근한다면 아래와 같을 것이다.  
**{5, 5, 1, 1}을 사용해서 총 4일거야!** 라고 답을 도출하겠지만  
사실은 **{4, 4, 4}를 사용해서 총 3입니다!** 가 답입니다.  

모든 방식을 다 찾아보는 Brute Force 알고리즘을 쓴다고 하면 답은 찾을 수 있겠지만  
입력의 크기가 매우 커진다면 속도는 기하급수적으로 느려질 것이 뻔하다.  

이런 단점을 보완하기 위해서 **동적 계획법**이 필요한 것이다!

### 6.1.2 최적해 구하기
동적 계획법을 사용하기 위해서는 **재귀적으로 접근하는 방법**을 고민해봐야한다.  
위와 같은 케이스에서는 1을 만드는 경우부터 n을 만드는 경우를 생각해봐야하는데,  
각 단계마다 최적의 해를 구하기 위해서는 이전의 단계 값을 참고하는 것이 필수적이다.  

```
solve(x) = INF (x<0)
solve(x) = 0 (x=0)
solve(x) = min(solve(x-c)+1) (x>0)
```
위의 점화식을 설명하자면, x가 0보다 작은 경우는 존재할 수가 없기 때문에 INF 값으로 두었다.  
x=0인 경우에는 모든 코인을 사용해도 만들 수가 없으므로 답은 0이다.
그 외 케이스인 경우에는 현재 x값에서 모든 코인을 빼고 + 1을 한 최소 값이 답이 된다.

```cpp
int solve(int x){
    if(x<0) return 99999999;
    if(x==0) return 0;
    if best = 99999999;
    for(auto a : coins){
        best = min(best, solve(x-a));
    }
    return best;
}
```
위와 같이 구현한 함수는 solve를 계속 타고 들어가기 때문에 속도적인 측면에서 비효율적이다.
이를 개선하기 위해서는 **메모이제이션** 기법을 사용하면 된다.

#### **메모이제이션**
위의 함수 값을 흘려보내지 않고 배열에 저장하여 재사용하는 기법이다.  
`bool ready[N]`은 solve(x)가 계산되었는지 체크하고  
`int value[N]`은 solve(x)가 계산된 값을 넣는 변수로 지정한다.
그러면 코드는 아래와 같이 변한다.  
```cpp
int solve(int x){
    if(x<0) return 99999999;
    if(x==0) return 0;
    if(ready[x]) return value[x];
    if best = 99999999;
    for(auto a : coins){
        best = min(best, solve(x-a));
    }
    ready[x] = true;
    value[x] = best;
    return best;
}
```
저장된 값을 가지고 return을 해주기 때문에 복잡도가 상당하게 줄어드는 것을 확인할 수 있다.

#### **반복문을 이용한 구현**
위의 코드를 반복문으로만 구현할 수 있다.
```cpp
value[0]=0;
for(int x=1; x<=n; x++){
    value[x]=9999999;
    for(auto c : coins){
        if(x-c>=0)
            value[x] = min(value[x-c]+1, value[x]);
    }
}
```
위의 코드가 더 간결하고 속도 또한 빠르다.  
하지만 동적계획법을 구상하기에는 재귀함수로 표현하는 것이 더 쉽다.

#### **해답 구성하기**
위의 답에 대한 코인의 구성 내용을 아래와 같은 로직으로 찾을 수 있다.
```cpp
vector<int> v;
for(int x=1; x<=n; x++){
    value[x]=9999999;
    for(auto c : coins){
        if(x-c>=0 && value[x-c]+1<value[x]){
            value[x] = value[x-c]+1;
            v.push_back(c);
        }
    }
}
for(auto c : v){
    cout << c << endl;
}
```

#### **해의 개수 세기**
동전 문제를 변형하여 합 x를 만드는 경우의 수를 세는 문제도 있다.  
재귀적인 방법으로 해결할 수 있는데 아래의 로직과 같다.  
1. 합 x를 만드는 경우의 수를 `solve(x)`라고 나타내자.  
2. 점화식은 아래와 같다.
```
coin = {1,3,5} 일 떄
solve(x) = solve(x-1) +
            solve(x-3) +
            solve(x-5)
```
그리고 이를 일반화하면 아래와 같다.  
```
solve(x) = 0 (x<0)  
solve(x) = 1 (x=0)
solve(x) = sum(solve(x-c)) (x>0, c=coin)
```
이를 토대로 x에 대한 해답을 찾을 수 있게 된다.  
코드는 아래와 같다.
```cpp
count[0] = 1;
for(int x=1; x<=n; x++){
    for(auto c : coins){
        if(x-c>=0) count[x] += count[x-c];
    }
}
```

## 6.2 다른 예제
앞서 소개한 내용은 동적계획법의 기본과 그 예제였다.
이제 동적계획법을 이용해서 효율적으로 문제를 푸는 것을 보자.

### 6.2.1 최장 증가 부분 수열
원소가 n개인 배열의 일부 원소를 골라 만든 부분 수열 중  
각 원소가 이전 원소보다 크다는 조건을 만족하면서 그 길이가 최대인 것을 **최장 증가 부분 수열** 이라고 한다.  

`[6,2,5,1,7,4,8,3]`이라는 배열이 존재할 때 위의 조건을 만족하는 부분배열은  
`[2,5,7,8]`이다.  

어떻게 동적 계획법을 사용할까?  

먼저 `lenght(k)`를 최장 증가 부분 수열의 길이라고 생각하자.  
그렇다면 이 `length(k)`를 계산하기 위해서는 어떤 로직이 필요할까.  

조건 1. 이전 원소보다 커야한다.  
조건 2. 길이가 최대여야한다.  
라는 힌트를 이용해보면  
`array[k]>array[i]`이면서 `length[k]`가 최대로 되어야 한다.  

그렇다면 `length[k]=max(length[k], length[i]+1)`이라는 공식이 생긴다.  
이를 토대로 코드를 작성하면 아래와 같다.  
```cpp
for(int k=0; k<n; k++){
    for(int i=0; i<k; i++){
        if(arr[i]<arr[k]) 
            length[k] = max(length[k], length[i]+1);
    }
}
```
이 알고리즘은 `O(n^2)`의 시간복잡도를 가진다.

### 6.2.2 격자상의 경로
n*n 격자가 있을 때, 왼쪽 위 지점에서 오른쪽 아래 지점으로 가는 경로를 구하는 문제.  
갈 수 있는 경로는 오른쪽 혹은 아래로만 가능하다.  

각 지점에는 정수가 존재하며, 지나가는 길의 값을 모두 더한 값이 커야한다.  
특정한 지점 `(x,y)`에 도달하기 위한 최대 값을 가지는 경로는  
위의 규칙에 따라서 아래와 같을 것이다.  
`sum(x,y) = max(sum(x-1,y),sum(x,y-1))`  

위의 식이 나오는 이유는 간단하다.  
특정한 지점 `(x,y)`에 도달하기 위해서는 규칙으로 인해  
`(x-1,y)`혹은 `(x,y-1)`에서 밖에 올 수가 없기 때문이다.

위의 문제를 코드로 간단하게 작성하면 아래와 같다.
```cpp
for(int y=1; y<=n; y++){
    for(int x=1; x<=n; x++){
        sum[y][x] = max(sum[y][x-1], sum[y-1][x-1])+value[y][x];
    }
}
```  
이 알고리즘은 `O(n^2)`의 시간복잡도를 가진다.  

### 6.2.3 짐 싸기 문제
흔히 Knapsack Problem이라고 많이 알려진 배낭문제이다.
이 문제에는 제약조건을 걸어 문제를 변형시키기도 하는데  
이 책에서는 weight List가 주어지면 해당 weight만 사용하여  
구할 수 있는 모든 합을 구하는 문제이다.  

가령 `[1,1,2,3]`이 주어진다면  
아무것도 선택하지 않는 경우를 포함하여 모든 원소를 포함하는 경우까지  
`[0,1,2,3,4,5,6,7]`를 만들 수 있을 것이다.

로직을 짜보자.  
원소의 개수를 k, 원소들의 합을 m이라고 두자.  
그렇다면 처음부터 k까지의 원소를 가지고 m을 만들 수 있는지 체크하는 방법은 무엇일까?  
첫 번째로 k-1까지 원소로 m을 만들 수 있는 경우.  
두 번째로 k-1까지 원소로 m-w를 만들 수 있는 경우.(w는 k위치에 있는 원소의 값)  

말로하니 어렵다. 표를 그려보자.  

| NA | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
|---|---|---|---|---|---|---|---|---|
| k=0 | O | X | X | X | X | X | X | X |
| k=1 | O | O | X | X | X | X | X | X |
| k=2 | O | O | O | O | O | X | X | X |
| k=3 | O | O | O | O | O | O | O | X |
| k=3 | O | O | O | O | O | O | O | O |

가령 위의 표를 참고하여 k=3이고 x가 6인 경우를 살펴보자.  
위의 케이스를 참고할 첫 번째 데이터는 k=2이면서 x=6인 경우이다.  
표에서 나타나듯 해당 case는 불가능함을 보여준다.  

두 번째 데이터는 k=2이면서 x-w=4인 경우이다.(여기서 w는 weight중 3번째 원소인 2를 나타낸다.)  
표에서 나타나듯 해당 case는 가능함을 보여준다.  
따라서 3번째 원소인 2를 사용하면 원소를 총 3개 사용하는 것이므로 k=3, x=6인 경우는 가능함을 보여준다.  

이를 간단하게 표현하자면  
`possible(x,k) = possible(x-w[k],k-1) OR possible(x, k-1)`  
로 표현이 가능하고 아래의 코드처럼 구현 할 수 있다.
```java
 possible[0][0] = true;
        for(int k=1; k<=n; k++){
            for(int x=0; x<=m; x++) {
                if (x - weight[k] >= 0)
                    possible[x][k] |= possible[x - weight[k]][k - 1];
                possible[x][k] |= possible[x][k - 1];
            }
        }
```

> 작성중.
