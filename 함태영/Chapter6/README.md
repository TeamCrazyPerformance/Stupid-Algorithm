# Chapter6. 동적 계획법(Dynamic programming)

문제의 최적해를 구하거나 답의 개수를 세는 과정에서 응용이 가능하다.  
간단 탐욕알고리즘은 항상 최적의 해를 내놓지 않다는 단점을 보여주면서  
동적 계획법에 대한 공부를 시작해보자.  

## 6.1 기본 개념
동적 계획법의 기본 요소를 알아본다.  
### 6.1.1 탐욕법이 실패하는 경우
앞서 소개한 **간단한 탐욕알고리즘은 항상 최적의 해를 내놓지 않는다** 를 확인해보자.  
```
코인 { 1,3,4,5 } 가 있다.
코인들을 사용하여 12를 만들 때, 최소로 사용한 코인의 갯수를 알아보자.
```
만약 탐욕 알고리즘으로 접근한다면 아래와 같을 것이다.  
**{5, 5, 1, 1}을 사용해서 총 4일거야!** 라고 답을 도출하겠지만  
사실은 **{4, 4, 4}를 사용해서 총 3입니다!** 가 답입니다.  

모든 방식을 다 찾아보는 Brute Force 알고리즘을 쓴다고 하면 답은 찾을 수 있겠지만  
입력의 크기가 매우 커진다면 속도는 기하급수적으로 느려질 것이 뻔하다.  

이런 단점을 보완하기 위해서 **동적 계획법**이 필요한 것이다!

### 6.1.2 최적해 구하기
동적 계획법을 사용하기 위해서는 **재귀적으로 접근하는 방법**을 고민해봐야한다.  
위와 같은 케이스에서는 1을 만드는 경우부터 n을 만드는 경우를 생각해봐야하는데,  
각 단계마다 최적의 해를 구하기 위해서는 이전의 단계 값을 참고하는 것이 필수적이다.  

```
solve(x) = INF (x<0)
solve(x) = 0 (x=0)
solve(x) = min(solve(x-c)+1) (x>0)
```
위의 점화식을 설명하자면, x가 0보다 작은 경우는 존재할 수가 없기 때문에 INF 값으로 두었다.  
x=0인 경우에는 모든 코인을 사용해도 만들 수가 없으므로 답은 0이다.
그 외 케이스인 경우에는 현재 x값에서 모든 코인을 빼고 + 1을 한 최소 값이 답이 된다.

```cpp
int solve(int x){
    if(x<0) return 99999999;
    if(x==0) return 0;
    if best = 99999999;
    for(auto a : coins){
        best = min(best, solve(x-a));
    }
    return best;
}
```
위와 같이 구현한 함수는 solve를 계속 타고 들어가기 때문에 속도적인 측면에서 비효율적이다.
이를 개선하기 위해서는 **메모이제이션** 기법을 사용하면 된다.

#### **메모이제이션**
위의 함수 값을 흘려보내지 않고 배열에 저장하여 재사용하는 기법이다.  
`bool ready[N]`은 solve(x)가 계산되었는지 체크하고  
`int value[N]`은 solve(x)가 계산된 값을 넣는 변수로 지정한다.
그러면 코드는 아래와 같이 변한다.  
```cpp
int solve(int x){
    if(x<0) return 99999999;
    if(x==0) return 0;
    if(ready[x]) return value[x];
    if best = 99999999;
    for(auto a : coins){
        best = min(best, solve(x-a));
    }
    ready[x] = true;
    value[x] = best;
    return best;
}
```
> 작성중.