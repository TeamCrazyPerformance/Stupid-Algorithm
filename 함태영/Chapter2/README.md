# Chapter2
## 2.1 언어적 특성
```
#include<bits/stdc++.h>
using namespace std;
int main(){
~~
}
```
C++이 알고리즘 대회에서 어떤 형태를 지니는지 설명하고 있다. (Java와 섞어서 알고리즘을 풀 예정이라 같이 정리한다.)
 `#include<bits/stdc++.h>`는 C++ 표준 라이브러리를 모두 포함하는 g++ 컴파일러의 기능이다. (Iostream, vector, algorithm 등)

작성된 코드는 아래의 명령어로 실행된다.
`g++ -std=c++11 -02 -Wall test.cpp -o test`
명령어를 해석하자면 이 소스는 C++11의 표준을 따르며 코드 최적화를 진행하고(-02)
발생가능한 오류에 대해 경고를 알려준다(-Wall)는 의미이다.
### 2.1.1 입력과 출력
> 생략하겠다.

### 2.1.2 수를 처리하는 방법
이 part는 초보자들이 꼭 읽었으면 했다.
#### 정수
값을 받는 변수의 크기로 인해 실패하는 경우가 종종 있는데, 이는 자료형의 문제이다.
대부분의 사람들은 int를 많이 사용하지만, 이 int는  32bit 자료형으로 대략 -2*10^9 ~ 2*10^9 정도의 범위를 가지며, 이 데이터의 범위가 넘어간다면 64bit 자료형인 *long long* 을 쓰면 된다. 대략 -9*10^18 ~ 9*10^18 정도의 범위를 가진다.
> 참고로 long long 자료형을 쓴다면 대입하는숫자 뒤에 *LL*을 꼭 붙여주기를 바란다.

#### 나머지 연산
엄청 큰 값에 대한 나머지를 구하는 팁을 설명하고 있다.
예를 들어 `x!에 대해 m으로 나눈 나머지를 구해봐` 라고 했을 경우에는
x가 큰 값이 들어오면 결과 값이 매우 커져 Overflow를 유발할 수 있다.
이는 modulo 연산에 대한 간단한 공식으로 해결이 가능하다.
```
(a+b) mod M = (a mod M + b mod M) mod M
(a-b) mod M = (a mod M - b mod M) mod M
(a*b) mod M = (a mod M * b mod M) mod M
```

> 만약 음수의 나머지가 발생하는 경우가 존재한다면, 해당 결과 값에 M을 더해주면 된다.

#### 부동 소수점 실수
정밀도를 생각하면 double이 아닌 long double을 사용하자.
또한 부동 소수점은 약간의 오차가 있는데, 다들 double 자료형의 변수끼리 *==* 연산을 했을 때 원하지 않는 결과를 주는 것을 확인 할 수 있다.
그 이유는 서로 약간의 오차가 존재해 같을 수가 없기 때문인데(같을 수도 있다..ㅎㅎ)
이를 해결하기 위해서는 아래의 코드를 사용하자
`abs(a-b)<1e-9` 

이렇게 사용하게 되면 a와 b가 같음을 비교할 수 있다.

### 2.1.3 코드 짧게 만들기
이 파트는 매우 유용했다.
자료형에 대해서 너무 긴 경우가 있다.
예를 들어 long long, vector<int> 와 같이 말이다.(이는 c++ 기준이다.)
이 때 아래와 같이 쓴다면 효율적으로 코드를 짧게 만들 수 있다.

```
typedef long long ll;
ll a = 1;
```

다른 방법으로는 매크로를 정의하는 것이있다.
```
#define F first
#define REP(i,a,b) for(int i=a;i<=b;i++)
v[i].F; // v[i].first; 와 동일한 기능을 한다.
REP(i, 1, n){
	search(i);
}
// 위 로직은 아래 for문과 완벽하게 호환이 된다.
for(int i =1; i<=n; i++){
	search(i);
}
```

## 2.2 재귀적 알고리즘
재귀적 알고리즘은 답의 후보를 하나씩 살펴보는 알고리즘이다.

### 2.2.1 부분집합 생성하기
만약 원소가 n개인 집합의 모-든 부분집합을 구하려면 어떻게 하면 될까?
단순하게 원소 하나는 집합에 들어갈 수도, 들어가지 않을 수도 있다는 아이디어로 접근하면 된다.
이를 이용해 간단하게 flow를 짜본다면 아래와 같을 것이다.
```
vector<int> subset;
void search(int k){
	if(k == n+1){
		//k가 원소의 끝일 때
	}
	else{
		subset.push_back(k); // k를 부분집합에 포함하는 경우
		search(k+1);
		subset.pop_back(); // k를 부분집합에 포함하지 않는 경우
		search(k+1);
	}
}
```

### 2.2.2 순열 생성하기
부분집합과 다르게 주어진 집합 내에서 가능한 모든 순열을 찾는 알고리즘이다.
.. 코드가 이해안된다. 스터디하면서 정리하자.
> 원래 내가 아는 코드는 원소 swap을 재귀로 호출하면서 순열을 만드는데, 이 코드는 뭔지 모르겠다.

### 2.2.3 퇴각 검색
흔히 Backtracking 기법이라는 알고리즘이다.
해가 없는 상태로 시작하면서, 가능한 모든해를 찾으며 확장해가는 방식이다.
이 책에서는 n*n 체스판에서 n개의 퀸이 서로를 공격할 수 없는 배치 방법의 수를 찾는 문제를 내고 있다.
비어있는 체스판에 퀸 하나를 올리고, 그 퀸을 잡지 않는 위치에 다른 퀸을 놓는다. 이렇게 n개의 퀸을 모두 올릴 수 있다면 해를 찾은 것이다.
```
int col[n+1]; // 퀸이 존재하는 열을 저장하는 배열
int diag1[n+1]; // 대각선 추적 배열
int diag2[n+1]; // 대각선 추적 배열
int count = 0;

void search(int y){
	if( y == n ){ // y가 체스판의 한 변의 크기만큼 왔다면 성공이다.
		count++;
		return;
	}
	for(int x=0; x<n; x++){
		if(col[x] || diag1[x+y] || diag2[x-y+n-1]) continue;
		col[x] = diag1[x+y] = diag2[x-y+n-1] = 1;
		search(y+1);
	}
}
```
각각 배열이 필요한 이유는
1. 퀸이 존재하는 열에는 다른 퀸이 있을 수가 없다.
2. 퀸이 존재하는 행에는 다른 퀸이 있을 수가 없다. 
3. 퀸이 존재하는 대각선에는 다른 퀸이 있을 수가 없다.
를 체크하기 위함이다.
이에 대한 그림은 그림 2.4를 참조하면 된다.

## 2.3 비트 연산
할 필요가 있을까. 나중에 읽을래.
### 2.3.1 비트 연산
### 2.3.2 집합 표현하기


