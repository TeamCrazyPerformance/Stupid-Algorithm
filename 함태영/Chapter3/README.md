# Chapter3. 효율성
알고리즘의 효율성은 속도와 관련이 있다.
주어진 문제에 대해서 얼마나 빠르게 해결을 할 수 있는지에 대한 지표가 효율성이며
이를 *시간복잡도*라는 개념으로 접근할 수 있다

## 3.1 시간복잡도
알고리즘의 시간복잡도는 들어온 Input에 대해 얼마만큼의 시간을 사용하는지를 알려주는데, 이 시간복잡도를 가지고 알고리즘의 속도가 얼마나 빠른지 근사적으로 확인 할 수 있다.

시간복잡도는  `O(...)` 로 표현하며 괄호 안에는 함수의 형식으로 표현이 된다.
`n`은 입력의 크기이며 `n`을 이용하여 함수를 만들어 표현하면된다.

### 3.1.1 계산 규칙
#### `O(1)`
시간복잡도 `O(1)`(상수 시간 알고리즘)은 상수 시간에 문제를 해결 할 수 있음을 의미한다.
코드가 단일 명령어로 구성되있는 경우,  입력 크기에 관여받지 않고 바로 계산할 수 있는 경우가 이러한 Case에 속한다.
```cpp
a++;
b++;
c = a+b;
```

#### `O(n)`
시간복잡도 `O(n)`(선형시간 알고리즘)은 입력 크기인 `n`만큼 접근해야 문제를 해결 할 수 있음을 의미한다. 가장 간단한 예제로 반복문이 존재한다.
대부분의 알고리즘 문제는 선형시간 알고리즘이 가장 효율적인 시간 복잡도인데, 이는 해결을 위해 입력으로 들어온 값들을 모두 한 번씩은 살펴봐야하기 때문이다.
> 반복문을 중간에 중단하는 경우도 있겠지만, *근사치*로 n번 반복한다 생각을 해서 `O(n)`이라 생각하면 된다.
> 또한, 반복은 3n번 한다고 해서 시간복잡도는 `O(3*n)`이 아니다. 근사적으로 접근한다는 점에서 상수만큼 곱한 것은 생각하지 않는다. --> 크게 영향을 끼치지 않기 때문이다.
```cpp
for(int i = 0; i<n; i++){
	//something code
}
```

#### `O(n^k)`
일반적으로 시간복잡도가 `O(n^k)`인 경우에는 입력 크기인 `n`만큼 반복하는 반복문을 중첩하는 경우 생긴다.
```cpp
for(int i = 0; i<n; i++){
	for(int j = 0; j<n; j++){
		//something code
	}
}
// O(n^2)
```
보통 k에 따라서 k개의 원소 조합을 모두 찾을 수 있다. ( k=3이라면 3개의 원소를 가지는 모든 집합을 찾아낼 수 있다.)

#### `O(nm)`
시간복잡도 `O(nm)`같은 경우는 여러 인자에 의해 영향을 받을 경우 이와 같이 표현한다.
예를 들자면, 문제해결에 영향을 끼치는 input 인자가 2개이상인 경우 해당된다.
```cpp
for(int i = 0; i<n; i++){
	for(int j = 0; j<m; j++){
		//something code
	}
}
```

#### 기타 다른 시간복잡도
---
##### 1. 재귀함수의 시간 복잡도
재귀함수의 시간복잡도는 구현 방법에 따라 결정된다.
해당 재귀함수가 어떻게 호출되며, 몇 번 호출될지 대략적으로 찾아야 결정이 된다.
`O(1)`이 될지, `O(n^2)`이 될지는 구현방식에 따라 다른 것이다.

##### 2. `O(log n)`
로그 시간 알고리즘이라 불리는 이 시간 복잡도는 매 단계마다 입력크기를 반토막 낸다.
가장 대표적인 알고리즘으로 *이진탐색 알고리즘*이 존재하는데 탐색 범위를 절반씩 줄여나가는 방법으로 목표값을 찾기에 `O(log n)`의 시간만에 해결할 수 있다.

##### 3. `O(n log n)`
이 시간 복잡도는 Input 데이터를 정렬하는 알고리즘에서 자주 보이는 시간복잡도이다.
가장 효율적인 정렬 알고리즘 시간 복잡도가 `O(n log n)`이라 알려져있다.
다른 경우에는 `n`번 반복하되, 1번 연산 수행시 `O(log n)`의 시간이 걸리는 연산을 진행하는 경우가 있다.

##### 4. `O(2^n)`
이 시간 복잡도는 조합에서 많이 보인다.
모든 원소에 대한 부분집합을 구하는 알고리즘에 많이 보인다.
> 이 외에는 모르겠다ㅜㅜ 
---
##### 5. `O(n!)`
이 시간복잡도는 모든 원소에 대해서 모든 순열을 한 번씩 살펴보는 알고리즘이다.
`{1,2,3}` 원소에 대해서 구할 수 있는 순열을 모두 탐색하는 경우 `3!`의 시간이 걸린다.

보통 `O(n^k)`를 넘지 않으면 *다항 시간 알고리즘* 이라고 하며 위에 정리한 시간복잡도 중에서는 `O(2^n), O(n!)`만 제외하면 모두 다항 시간 알고리즘이다.
> 다항 시간 알고리즘은 입력이 매우 커도 *대체적으로 빠른시간 내에 해결이 가능하다* 라는 뜻이다. 이외에는 너무 많은 시간이 걸린다.

### 3.1.3 효율성 추정
알고리즘 문제마다 input과 제한 시간이 존재한다.
이를 기반으로 우리는 어떤 시간 복잡도로 문제를 해결 할지를 추정할 수 있다.
| 입력의 크기 | 추정 시간 복잡도 | 
| —
| n <= 10 | O(n!) | 
| n <= 20 | O(2^n) | 
| n <= 500 | O(n^3) | 
| n <= 5000 | O(n^2) | 
| n <= 10^6 | O(n log n) or O(n) | 
| n is large | O(1) or O(log n) | 

> 위 표는 1초 기준이며 컴파일 환경에 따라 다를 수도 있다.

Input 데이터가 10^5개라면 해당 문제는 `O(n log n) or O(n)` 시간 복잡도를 가지는 알고리즘으로 해결해야함을 알 수 있을 것이다.

하지만, 이것은 *추정* 일 뿐이며 `O(n)` 시간 복잡도이지만 `n/2` 연산을 진행하는 알고리즘과 `5*n` 연산을 진행하는 알고리즘과 시간 차이는 많이 존재한다는 것을 염두해야한다.

### 3.1.4 엄밀한 정의
> PASS, 정확히 알아야할 필요는 없어보인다.

## 3.2 예제 문제

