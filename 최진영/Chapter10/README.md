# 트리 알고리즘

## 기본 기술
- 트리 : 노드 n개와 간선 n-1개로 이루어진 사이클 없는 연결 그래프를 말한다.
- 리프 : 이웃이 하나만 있는 노드를 말한다.

- 루트트리 : 노드 중 하나가 루트로 지정되어 있으며 다른 노드는 루트 노드 아래에 위치한다.
- 자식 : 루트트리에서 자신보다 아래에 위치한 노드를 말한다.
- 부모 : 루트트리에서 자신보다 위에 위치한 노드를 말한다.
- 루트트리의 구조는 재귀적이다.
- 서브트리 : 자신과 각 자식 노드의 서브트리에 속한 노드로 구성된다.

### 트리 순회

#### 재귀함수
`
def dfs(s,e) :
  for i in adj[s]:
    if u != e : def(i,s)
`

#### 동적계획법
`
def dfs(s,e) :
  count[s] = 1
  for i in ads[s]:
    if u == e : continue
    dfs(i,s)
    count[s] += count[i]
`
> 이때, count 에는 노드 s의 서브트리의 노드 수가 들어간다.

#### 이진 트리 순회
- 전위 순회 : 루트노드 -> 왼쪽 서브트리 -> 오른쪽 서브트리 순으로 순회한다.
- 중위 순회 : 왼쪽 서브트리 -> 루트노드 -> 오른쪽 서브트리 순으로 순회한다.
- 후위 순회 : 왼쪽 서브트리 -> 오른쪽 서브트리 -> 루트노드 순으로 순회한다.

### 지름 계산하기
- 지름 : 두 노드 간 경로 길이 중 최댓값이다.

#### 동적계획법
- 우선 임의의 노드를 루트로 지정한 다음 각 서브트리에 대해 따로따로 문제를 푸는 것이다.
- 경로에 속한 가장 높은 위치의 노드가 있기 때문에 각 x노드에 대해 가장 높은 지점의 노드가 x가 되는 가장 긴 경로의 길이를 구할 수 있다.

#### 깊이 우선 탐색
- 먼저 트리에서 임의의 노드 a를 선택한 뒤, 이 노드에서 가장 먼 노드 b를 찾는다.
- 그리고 b에서 가장 먼 노드 c를 찾는다. 트리의 지름은 b와 c의 거리가 된다.

### 모든 최장 경로
- 모든 노드 x에 대해 x에서 시작하는 경로의 최대 길이 maxLength(x)를 구하는 문제이다.
- 트리의 루트를 임의로 지정하는 것으로 시작한다. 모든 노드 x에 대해 x의 자식 노드 방향으로 내려가는 경로의 최대 길이를 구하는 것이다.
- 그 다음 모든 노드 x에 대해 부모 노드 p방향으로 올라가는 경로의 최대 길이를 구하는 것이다.
- 둘 중 큰 값이 최장 경로가 된다.

## 트리 질의

### 조상 찾기
- 루트 트리에서 노드 x의 k번째 조상은 x에서 시작하여 k번 위로 올라간 노드이다.
- 노드 x의 k번쨰 조상을 ancestor(x,k)라고 나타내자. 조상이 없으면 값 0으로 생각한다.
- ancestor(x,k)의 값을 k가 2의 거듭 제곱인 경우에 대해 미리 계산을 하면 답을 좀 더 효율적으로 구할 수 있다.

### 서브트리와 경로
- 트리 순회 배열 : 루트 트리의 노드를 루트 노드에서부터 깊이 우선 탐색으로 방문하는 순서대로 담은 배열이다.
- 트리의 각 서브트리는 트리 순회 배열의 부분 배열에 대응되고, 부분 배열의 첫 번째 원소가 그 서브트리의 루트 노드가 된다.

#### 서브트리 질의
- 노드의 값을 갱신하는 질의와 서브트리에 대해 값의 합을 계산하는 질의이다.
- 트리 순회 배열을 만들고, 각 노드에 대해 노드의 번호, 서브트리의 크기, 노드의 값을 배열로 저장한다.
- 노드의 값을 이진 인덱스 트리 혹은 구간 트리에 저장하면 답을 좀 더 효율적으로 구할 수 있다.

#### 경로 질의
- 노드의 값을 갱신하는 질의와 루트 노드부터 특정 노드까지 가는 경로의 합을 구하는 질의이다.
- 트리 순회 배열을 만들고, 각 노드에 대해 노드 번호와 서브트리의 크기, 루트 노드로 부터 해당 노드까지 이어지는 경로의 합을 배열에 저장한다.
- 이진 인덱스 트리 혹은 구간 트리와 차이 배열을 이용하면 답을 좀 더 효율적으로 구할 수 있다.

### 최소 공통 조상
- 루트 트리에 속한 두 노드의 최소 공통 조상은 두 노드를 모두 서브트리에 포함하고 있는 가장 낮은 노드이다.

#### 첫번째 방법
- 트리의 임의의 노드에 대해 k번째 조상을 효율적으로 찾을 수 있다는 것을 이용한다. 각 노드를 가르키는 두 포인터를 이용한다.
- 포인터가 가르키는 노드가 같은 높이에 있도록 조정한다.
- 그 다음 두 포인터가 같은 노드를 가리키게 하려면 위로 최소 몇번 이동해야 하는지를 구한다.

#### 두번째 방법
- 오일러 투어 트리라고 부르는 확장된 트리 순회 배열을 기반으로 한다.
- 깊이 우선 탐색으로 모든 노드를 방문하되, 그 과정에서 노드를 지나는 모든 순간마다 노드를 배열에 추가한다. 이때, 노드의 깊이도 추가한다.
- 배열에서 노드 a와 b사이의 노드 중 깊이가 최소인 노드가 최소 공통 조상이 된다.

#### 거리 계산하기
- 노드 a와 b를 잇는 경로의 길이를 계산하는 질의를 처리하는 문제이다. 두 노드의 최소 공통 조상을 찾는 문제로 변환할 수 있다.
- 임의의 노드를 트리의 루트로 정한다. 이때 c는 노드 a와 b의 최소 공통 조상이다.
- `depth(a)+depth(b)-2*depth(c)`를 통해 답을 계산할 수 있다.

### 자료구조 병합하기
- 온라인 알고리즘 : 질의를 하나씩 처리하는 방식의 알고리즘, 다음 질의전 이전 질의의 답을 내야한다.
- 오프라인 알고리즘 : 질의 전체의 집합이 한번에 주어지며 순서에 상관없이 답을 구해도 된다.
- 오프라인 알고리즘을 만드는 한가지 방법은 깊이 우선 트리 탐색을 수행하면서 노드에 대한 자료 구조를 관리하는 것이다.

## 고급 기술

### 센트로이드 분해
- 트리의 센트로이드는 노드가 n개인 트리의 노드 중 하나로 그 노드를 삭제하면 노드가 최대 math.ceil(n/2)개인 서브르티로 나눈다는 특징을 만족하는 노드이다.
- 이를 위해 임의의 노드를 루트로 정의한 뒤, 서브트리 중 노드의 수가 최대인 쪽으로 이동하는 과정을 현재 노드가 센트로이드가 될때까지 반복한다.
- 센트로이드 분해의 첫번째 과정은 트리의 센트로이드를 찾은 뒤 센트로이드를 지나는 모든 경로를 처리하는 것이다.
- 그 다음 센트로이드를 경로에서 제거한 뒤 남은 서브트리를 재귀적으로 처리한다.
- 트리에서 길이가 x인 경로의 수를 구하는 문제에서 이를 다를 수 있다.

### 헤비-라이트 분해
- 트리의 노드를 여러 경로의 집합으로 나누는 방법이며, 각 경로를 무거운 경로라고 부른다.
- 임의의 두 노드 간 경로를 무거운 경로의 부분 경로 O(logn)개를 이어 붙인 형태로 나타낼 수 있다.
- 이를 위해 임의의 노드를 루트로 정의한 뒤, 루트에서 시작하여 서브트리의 크기가 가장 큰 자식 노드를 선택해 나가는 방법으로 첫번째 무거운 경로를 만든다.
- 그러고 난 후, 남은 서브트리에 대해 재귀적으로 이 과정을 반복한다.
- 트리의 경로 상의 노드를 배열을 원소처럼 다룰 수 있다.
