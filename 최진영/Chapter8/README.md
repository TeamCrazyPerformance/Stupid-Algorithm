# 알고리즘 설계 기법

## 비트 병렬 알고리즘
- 비트 연산을 수행할 때, 각 비트를 병렬적으로 처리할 수 있다는 사실에 입각한 알고리즘이다.

### 해밍거리
- 길이가 같은 두 문자열 a와 b사이에서 두 문자열이 일치하지 않는 위치의 개수를 구하는 문제이다.
- xor연산을 실행하고, 일치하지 않는 위치에 1이 들어있는 문자열의 1의 개수를 구한다.
- 각 비트에 대해 병렬적으로 처리하기 떄문에 일반 알고리즘보다 20배정도 빠르다.

### 부분 격자 세기
- 네 귀퉁이에 모두 검은색이 칠해져 있는 부분 격자의 개수를 구하는 문제이다.
- 각 행 k를 비트셋 형태로 표현하여 row[k]에 저장한다.
- and연산을 실행하고, 비트 1의 개수를 구해 a와 b행 모두에 검은색 지점이 있는 열의 개수를 구할 수 있다.
- 각 비트에 대해 병렬적으로 처리하기 떄문에 일반 알고리즘보다 40배정도 빠르다.

### 그래프 도달 가능성
- 노드 n개의 DAG에서 각 노드 x에서 도달가능한 노드의 개수 reach(x)를 구하는 문제이다.
- 노드에서 도달 가능한 노드의 목록을 n비트 비트셋 형태로 표현한다.
- or연산을 실행하여 두 목록의 합집합을 구한다.

## 분할 상환 분석
- 시간복잡도가 각기 다른 일련의 연산을 분석할 떄 사용할 수 있는 방법이다.
- 핵심은 개별 연산의 수행 시간에 집중하지 않고, 알고리즘 전체에 걸쳐 수행되는 연산의 총 수행 시간을 추청한다는 것이다.

### 두 포인터 기법
- 배열을 따라 포인터 두 개를 이동시켜 나가는 방법이다.
- 두 포인터 모두 한쪽 방향으로 움직인다.

- 양의 정수 n개로 이루어진 배열과 목표 합 x가 있을때, 합이 x인 부분배열을 구하는 문제를 예를 들어보자.
- 아이디어는 부분배열의 첫번째 값과 마지막 값에 대한 포인터를 관리하는 것이다.
- 단계마다 왼쪽 포인터는 오른쪽으로 한번 이동하고, x가 초과하지 않는 동안 오른쪽 포인터를 계속 이동한다.
- 왼쪽 포인터는 첫 번째 원소에서 시작하고 오른쪽 포인터는 세 번째 원소에서 시작한다.
- 왼쪽 포인터와 오른쪽 포인터 모두 O(n)번 움직이기 떄문에, 알고리즘 수행시간도 O(n)이 된다.

### 2SUM 문제
- 수 n개로 이루어진 배열과 목표 합 x가 있을 때, 합이 x가 되는 배열 원소 두개를 구하는 문제이다.
- 먼저 원소를 오름차순으로 정렬한다. 그리고 두 포인터를 이용하여 배열의 원소를 살펴본다.
- 왼쪽 포인터는 첫 번째 원소에서 시작하고 오른쪽 포인터는 마지막 원소에서 시작한다.
- 단계마다 왼쪽 포인터는 오른쪽으로 한번 이동한다. 오른쪽 포인터는 원소의 합이 x를 초과하지 않는 동안 왼쪽으로 계속 이동한다.
- 배열을 먼저 정렬하는데 O(nlogn)이 걸리고 두 포인터가 O(n)번 이동하기 때문에, 알고리즘의 수행시간은 O(nlogn)이다.

### 보다 작으면서 가장 가까운 원소
- 배열의 각 원소에 대해 그 원소보다 작으면서 가장 가까운 원소를 구하는 문제이다.
- 스택을 이용하여 이 문제를 효율적으로 풀 수 있다.
- 배열의 각 위치에 대해, 스택 맨위에 있는 원소가 현재 위치의 원소보다 작아질 떄까지 원소를 삭제한다.
- 각 원소에 대해 O(1)번의 연산만 수행하기 때문에, 이 알고리즘의 수행 시간은 O(n)이다.

### 슬라이딩 원도의 최솟값
- 어떤 배열에 대해서 왼쪽에서 오른쪽으로 움직여 나가는 고정된 크기의 부분 배열을 슬라이딩 윈도라고 한다.
- 이때, 슬라이딩 윈도의 최솟값을 구하는 문제이다.
- 덱을 이용하여 이 문제를 효율적으로 풀 수 있다.
- 덱의 각 원소가 점차 증가하도록, 그래서 덱의 첫 번쨰 원소가 윈도 안의 최소원소에 대응되도록 한다.
- 윈도를 한 칸 옮긴 후에는 덱의 마지막 원소가 윈도에 새로 추가된 원소보다 작아질 때까지, 덱의 뒤에서 부터 원소를 삭제해 나간다.
- 배열의 각 원소가 덱에 정확히 한번만 추가되고, 최대 한 번만 덱에서 삭제되므로, 알고리즘 수행시간은 O(n)이다.

## 최솟값 구하기
- 처음에는 감소하기만 하고, 최솟값에 도달한 후 이후에는 증가하는 함수를 미리 알고있다면 최솟값을 매우 효율적으로 구할 수 있다.

### 삼진 탐색
- 함수 f(x)를 최소화하는 x가 구간 [xl,xr]안에 들어있음을 알고 있다면 이 구간을 세조각 [xl,a] [a,b] [b,xr]로 나눌 수 있다.
- 이때 a = (2xl+xr)/3 b = (xl+2xr)/3 이다.
- 그러고 나면 f(a)<f(b)가 성립할 떄 최솟값이 [xl,b]안에 있음을 그렇지 않을 떄는 [a,xr]안에 있음을 알 수 있다.
- 구간의 범위가 충분히 좁혀질 때까지 재귀적으로 탐색을 반복해나간다.
- 새 구간의 길이는 항상 이전 구간 길이의 2/3배이므로, 알고리즘 수행시간은 O(logn)이다.

### 블록함수
- 어떤 함수의 그래프를 그렸을 때, 그래프의 두 점을 잇는 선분이 함수의 그래프 보다 항상 위쪽에 놓이면 그 함수는 볼록하다.
- 볼록함수를 최소화 하는 x가 구간 [xl,xr]안에 들어있음을 알고 있다면, 삼진 탐색ㅇㄹ 이용하여 최솟값을 할 수 있다.
- 그러나 볼록 함수를 최소화하는 점이 여러개 존재할 수 있음에 유의해야 한다.
- f(x)와 g(x)가 볼록함수인 경우, f(x)+g(x)와 max(f(x),g(x))도 볼록함수이다.

### 합 최소화
- n개의 수 a1,a2,a3...an이 있을 때 |a1-x|+|a2-x|+...+|an-x|를 최소화하는 x를 구하는 문제이다.
- 각각의 |ak-x|가 볼록 함수이기 때문에 그 합도 볼록함수가 된다. 따라서 삼진 탐색을 이용하면 x의 최적해를 구할 수 있다.
- 하지만 x의 최적해가 항상 주어진 수들의 중앙값이 된다는 사실을 구하면 더 효율적으로 x를 구할 수 있다.
