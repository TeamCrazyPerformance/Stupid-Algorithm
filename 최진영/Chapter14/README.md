# 문자열 알고리즘

## 기본 주제
- 부분 문자열 : 문자열의 연속된 글자가 나열된 형태를 말한다.
- 접두사 : 문자열의 첫 번째 글자를 포함한 부분 문자열을 말한다.
- 접미사 : 문자열의 마지막 글자를 포함한 부분 문자열을 말한다.
- 부분 수열 : 문자열의 일부 글자가 원래의 순서를 유지하며 나열된 형태를 말한다.

### 트라이 자료 구조
- 트라이 : 문자열의 집합을 관리하는 루트 트리이다.
- 주어진 문자열이 트라이에 포함되어 있는지를 확인하기 위해서는 루트 노드에서 시작하는 경로를 따라가 보면 된다.
- 새로운 문자열을 트라이에 추가하기 위해서는 필요한 경로를 따라가면서 필요할 때 새로운 노드를 추가하면 된다.
- 집합 내의 문자열 중 주어진 문자열이 접두사가 되는 문자열의 수를 세는 질의에서 효율적이다.

### 동적계획법

#### 최장 공통 부분 수열
- 두 문자열 모두의 부분 수열이 되는 문자열 중 가장 긴 수열의 길이를 구하는 문제이다.
- n,m을 x,y문자열의 길이, lcs(i,j) 을 x의 0~i까지와 y의 0~j까지의 최장 공통 부분 수열의 길이를 나타낸다.
- `lcs(i,j) = lcs(i-1,j-1)+1 if x[i]==y[j] else max(lcs(i,j-1),lcs(i-1,j))` 로 구할 수 있다.

#### 편집거리(레벤슈타인 거리)
- 첫 번째 문자열을 두 번째 문자열로 변환하기 위해 필요한 편집 연산의 최소 횟수를 구하는 문제이다.
- 편집 연산은 글자 삽입,삭제,수정이 존재한다.
- n,m을 x,y문자열의 길이, lcs(i,j) 을 x의 0~i까지와 y의 0~j까지의 편집 거리를 나타낸다.
- cost(i,j)는 i번째 있는 문자열과 j번째 문자열이 같아지기 위한 편집 연산의 횟수로써 x[i] == y[j] 면 0 x[i] != y[j] 면 1이다.
- `edit(i,j) = min(edit(i,j-1)+1,edit(i-1,j)+1,edit(i-1,j-1)+cost(i,j))` 로 구할 수 있다.

## 문자열 해싱
- 해시값 : 문자열의 글자를 이용하여 계산한 정숫값이다.
- 두 문자열이 같으면 해시값고, 따라서 해시값을 이용하여 문자열이 같은지 판단하는 것이 가능하다.

### 다항식 해싱
- `(s[0]A^(n-1)+s[1]A^(n-2)+...+s[n-1]A^0)mod B`로 해시값을 구한다.
- `p[k]=(p[k-1]A)mod B` 이용하면 문자열 s의 모든 부분 문자열의 해시값을 O(1)시간에 계산할 수 있다.
- 이때, 전처리 과정에서 O(n)이 걸린다.

### 응용

#### 패턴 매칭
- 문자열 s와 p가 있을 때, s내에서 p가 등장하는 위치를 찾는 문제이다.
- 해싱을 이용하면 문자열 비교를 O(1)시간에 할 수 있으므로 알고리즘의 전체 시간 복잡도는 O(n)이 된다.

#### 서로 다른 부분 문자열
- 어떤 문자열에 대해 길이가 k인 서로 다른 부분 문자열의 수를 세는 문제이다.
- 해싱을 이용하면 각 부분 문자열의 해시 값을 계산한뒤 서로 다른 정수의 개수를 셀 수 있다.

#### 사전 순 첫 번째 회전
- 주어진 문자열의 첫 번째 글자를 마지막으로 옮기는 과정을 반복함으로써 만들 수 있다.
- 먼저 문자열의 공통 접두사의 길이를 이분 탐색으로 찾는다. 이때, 해싱을 이용하면 O(1)시간에 판단할 수 있다.
- 그 다음, 공통 접두사 다음의 글자를 비교하여 문자열의 순서를 판단하면 된다.

#### 충돌과 상수
- 충돌 : 두 문자열의 내용이 다르지만 해시 값이 같은 경우
- 상수 A와 B를 잘 선정한다면 충돌이 발생할 확률을 낮출 수 있다.
- 일반적인 방법은 무작위로 선정한 10^9에 가까운 상수를 사용하는 것이다.
- 충돌 확률을 줄이기 위해 다른 상수를 이용하여 해시값을 여러번 계산하는 방법을 이용할 수 있다.

## Z알고리즘
- Z배열 : k = 0,1...,n-1에 대해 위치 k에서 시작하는 부분 문자열이면서 s의 접두사이기도 한 가장 긴 문자열의 길이를 저장하는 배열이다.

### Z배열 구하기
- 구간 [x,y]를 관리한다. s[x:y]는 s의 접두사이고 z[x]는 계산되어 있으며 y값은 가능한 값 중 최대여야 한다.
- y<k 인 경우, 위치 k에 대한 정보가 없기 때문에 부분 문자열을 한 글자씩 비교함으로써 z[k]의 값을 계산한다.
- y>=k 이고 k+z[k-x]<=y인 경우, z[k]=z[k-x]임을 알 수 있다.
- y>=k 이고 k+z[k-x]>y인 경우, 위치 y-k+1과 y+1부터 부분 문자열을 한글자씩 비교해 봐야 한다.

### 응용
- 해싱과 비슷한 문제에 응용가능하지만 Z알고리즘은 충돌의 위험이 없다.

#### 패턴매칭
- 문자열을 p#s의 형태로 만든다.
- p#s의 Z배열을 계산하면 s에서 p가 등장하는 위치를 찾을 수 있는데, 그 위치에 대응되는 원소의 값이 p의 길이와 같기 때문이다.

#### 경계 찾기
- 문자열의 접두사인 동시에 접미사이고, 원래 문자열 자신과는 다른 문자열로 문자열을 쪼개는 경계를 찾는 문제이다.
- 위치 k의 접미사가 경계일 조건은 k+z[k]=n인 경우와 동치이기 때문이다.

## 접미사 배열
- 접미사 배열 : 접미사의 사전순 순서를 나타내는 배열

### 접미사 배열 만들기
- 0라운드 : 모든 부분 문자열이 한 글자로 구성되므로, 문자에 번호를 붙이는 것이 가능하다.
- i번 라운드에서는 길이가 2^(i-1)인 부분 문자열에 붙은 번호를 이용하여 길이가 2^i인 부분 문자열에 붙일 번호를 결정한다.
> 이부분 너무 어렵다...

### 응용

#### 패턴 찾기
- 패턴을 한 글자씩 처리하면서 지금까지 처리했던 글자에 대응되는 접미사 배열의 범위를 관리하는 것이다.
- 이분 탐색을 이용하면 새로운 글자를 처리한 후에 구간 갱식을 효율적으로 할 수 있다.

#### LCP 배열
- 접미사 배열에서 현재 접미사와 다음 접미사의 최장 공통 접두사를 저장하는 배열이다.
- LCP 값이 x인 접미사의 경우, 첫 번째 글자를 제거한 접미사의 LCP값은 최소한 x-1이 되어하고 따라서 접미사의 처음 x-1글자는 비교하지 않아도 된다.
- n은 문자열의 길이이고 c는 LCP배열의 모든 값의 합일때 서로다른 부분 문자열의 수는 `n*(n+1)/2-c`이다.
