# 정렬과 탐색


## 4.1 정렬 알고리즘

정렬에서 다루는 기본적인 문제는 다음과 같다. 원소 n개로 이루어진 배열이 주어질 때, 원소들을 크기가 증가하는 순서로 정렬하라.
이 절에서는 기초적인 정렬 알고리즘 몇 가지와 그 성질에 대해 살펴본다.


### 4.1.1 버블정렬

버블정렬 (Bubble sort)은 O(n^2)시간에 동작하는 간단한 정렬 알고리즘이다. 이 알고리즘은 n번의 라운드로 이루어져 있으며 라운드마다 배열의 원소를 한 번씩 쭉 살펴본다. 연달아 있는 원소 두 개의 순서가 잘못되어 있는 것을 발견하면 두 원소를 맞바꾼다.

```
for i in range(n):
 for j in range(n-1):
  if array[j] > array[j+1] : array[j], array[j+1] = array[j+1], array[j]
```

- 역위

역위 (Inversion)란 배열 인덱스의 조합 (a,b)가 a<b 이지만 array[a]>array[b]를 만족할 때, 즉 원소의 순서가 잘못되었음을 의미한다. 역위의 개수는 배열을 정렬하는데 필요한 작업량을 나타낸다. 배열의 역위가 존재하지 않는다면 이는 정렬이 완벽하게 된 것이다.


### 4.1.2 병합정렬

병합정렬 (Merge sort)는 시간 복잡도 O(nlogn)을 가지며 재귀를 이용하는 정렬 알고리즘이다. 다음과 같이 정렬한다.

1. 만일 a=b라면 아무 것도 하지 않는다. 부분 배열이 원소 한 개로 이루어져 있으며, 이는 정렬되어 있기 때문이다.
2. 가운데 원소의 위치 k를 (a+b)/2 의 소수점 아래를 버린 값을 취한다.
3. 재귀적으로 부분 배열 array[a...k]를 정렬한다.
4. 재귀적으로 부분 배열 array[k+1...b]를 정렬한다.
5. 정렬된 부분 배열 array[a...k]와 array[k+1...b]를 병합하여 정렬된 부분 배열 array[a...b]로 만든다.

```
def merge(array,low,mid,high):
    i = low
    j = mid+1
    temp = [None] * len(array)
    for k in range(low,high+1):
        if i > mid :
            temp[k] = array[j]
            j += 1
        elif j > high :
            temp[k] = array[i]
            i += 1
        elif array[i] > array[j]:
            temp[k] = array[j]
            j += 1
        elif array[i] < array[j]:
            temp[k] = array[i]
            i += 1
    for k in range(low,high+1):
        array[k] = temp[k]
    return

def merge_sort(array,low,high):
    if low>=high: return
    mid = low + (high - low)//2
    merge_sort(array,low,mid)
    merge_sort(array,mid+1,high)
    merge(array,low,mid,high)


array = [2,5,6,4,8,9,7,1,0,3]
merge_sort(array,0,len(array)-1)
```

사실, 나눈 배열을 다시 합병하는 부분에서 어려움을 겪었는데 아래의 그림을 참고하면 합병에 대한 부분을 더욱 쉽게 이해할 수 있다.

![병합정렬](https://gmlwjd9405.github.io/images/algorithm-merge-sort/merge-sort.png)


### 4.1.3 정렬의 하한

배열의 원소를 비교하는 데에 기반을 둔 정렬 알고리즘으로 한정한다면, 배열을 O(nlogn) 시간보다 빠르게 정렬하는 것이 불가능하다.


### 4.1.4 계수 정렬

계수 정렬(Counting sort) 알고리즘란 배열의 모든 원소가 0...c 범위의 정수 이며 c=n일 때 O(n)시간에 배열을 정렬하는 알고리즘이다.
이 알고리즘에서는 일종의 장부와 같은 배열을 사용하며, 장부 배열의 인덱스는 원래 배열의 원소들이다.

```
import collections

array = [2,5,6,4,8,9,7,1,0,3]
dic = collections.Counter(array)
sort_array = []
for i,j in dic.items():
    for k in range(j) : sort_array.append(i)

```


### 4.1.5 실제 상황에서의 정렬

파이썬의 경우 내장함수 sort()와 sorted()가 존재한다. 이러한 라이브러리 함수를 이용할 떄의 장점이 여러가지가 있는데, 구현이 정확하고 효율적이며 사용하기에 편리하다.
만약 sort함수의 파라미터로 여러원소의 조합(tuple)이 온다면, 비교순위는 첫번째 원소 > 두번째 원소 ... > 마지막 원소 순으로 비교하여 정렬한다.

```
array = [2,5,6,4,8,9,7,1,0,3]
sort(array)
sorted_array = sorted(array)
```


## 4.2 정렬을 이용한 문제풀이


### 4.2.1 스왑 라인 알고리즘

스왑 라인 알고리즘(Sweep line Algorithm)은 정렬된 순서대로 처리되는 이벤트의 집합으로 문제를 모델링하는 방법이다.

스왑 라인 알고리즘을 사용하는 대표적인 문제는 어떤 특정일에 손님들이 한 음식점을 방문, 떠난 시간을 알 때 음식점에 동시에 존재했던 손님의 최댓값을 구하는 문제가 존재한다.

스왑 라인 알고리즘의 수행시간은 O(nlogn)인데, 이벤트를 정렬하는 데 O(nlogn)의 시간이 걸리고, 스왑 라인과 관련된 부분은 O(n)시간이 걸리기 때문이다.

> 스왑 라인 알고리즘에 관한 구현는 백준문제를 통해 자세히 풀어보자

### 4.2.2 이벤트 스케줄링

이벤트 n개의 시작 시각과 종료 시각이 주어질 때, 최대한 많은 수의 이벤트를 포함하는 스케줄을 구하려 한다. 이 문제의 경우, 입력 데이터를 여러가지 기준으로 정렬할 수 있다.

1. 이벤트 길이 순으로 정렬
2. 이벤트 시작 시각 기준으로 정렬
3. 이벤트 종료 시작 기준으로 정렬

이때, 이벤트 종료 시작 기준으로 정렬 했을 때에 최적해를 구할 수 있다. 이에 대한 증명은 넘어가자

> 이벤트 스케줄링에 관한 코드는 백준문제를 통해 자세히 풀어보자

### 4.2.3 작업과 데드라인

소요시간과 데드라인이 존재하는 작업의 스케줄링의 경우, 최적해는 소요시간이 짧은 순으로 스케줄링 한 것이 된다. 이에 대한 증명은 넘어가자

> 작업과 데드라인에 관한 코드는 백준문제를 통해 자세히 풀어보자


## 4.3 이진 탐색

이진 탐색 (Binary search)은 정렬된 배열에 특정 원소가 존재하는지 여부를 파악하는 등의 문제를 O(logn) 시간에 해결하는 알고리즘이다. 이 절에서는 먼저 이진탐색의 구현에 초점을 맞출 것이다.

- 첫번째 구현

처음에는 배열 전체를 놓고 시작한 후, 단계별로 진행해 나가면서 탐색 범위를 절반으로 줄여나간다.
중앙 원소가 목푯값과 같다면 종료, 크다면 오른쪽 배열 선택, 작다면 왼쪽 배열을 선택하여 재귀적으로 탐색을 계속해 나간다.

```
a = 0
b = n-1
while a<=b:
 k = (a+b)//2
 if array[k] == x : print(k)
 elif array[k] < x : a = k+1
 else b = k-1
```

- 두번째 구현

배열을 왼쪽에서 오른쪽으로 건너뛰어 가며 살펴보는 것이다.
처음에는 n/2개의 원소를 건너뛰고, 라운드마다 건너 뛸 원소 수를 절반씩 줄여나가면서 1이 될 떄 까지 진행한다.

```
k =0
b = n//2
while b >=1:
 while k+b < n and array[k+b] <= x : k + =b
 b //= 2
if array[k] == x : print(k)
```

- 실제 상황에서의 이진 탐색

파이썬에서는 bisect에 bisect 라이브러리 함수가 존재한다. 라이브러리 함수를 이용해서 좀 더 간편하게 이진탐색을 사용하자.

```
import bisect
mylist = [1, 2, 3, 7, 9, 11, 33]
print(bisect.bisect(mylist, 3))
```


### 4.3.2 최적해 구하기

어떤 문제를 풀 때, valid(x)라는 함수가 있어서 x가 올바른 해이면 True를 반환하고, 그렇지 않으면 False를 반환한다고 해보자. 이에 덧붙여서 Valid(x)가 X<k 일때 False이고 x>=k 일때 True임을 알고 있다고 해보자. 이때, 우리는 이진탐색을 이용하여 효율적으로 k를 구할 수 있다.

```
x = -1
b = z
while b>=1:
 while !valid(x+b) : x +=b
 b //=2
k = x+1
```
